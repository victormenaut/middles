

INTRODUCTION
BEFORE YOU START 1.1
This is a BBC BASIC reference manual, it is not intended to teach you BASIC nor tell you how the Z88 computer works.
It gives a summary of BBCBASIC(Z80)'s commands and functions plus some hints and tips on their use.
It also describes the minor differences between the Acorn 6502 and Z80 versions of BBC BASIC.
A general knowledge of BASIC has been assumed.
File handling with BBCBASIC(Z80) is more flexible than on the BBC Micro and different in approach to most other versions of BASIC.
Because of this, BBCBASIC(Z80) file handling has been covered in some detail.
Please read your Z88's documentation before you try to use it seriously.
We have included some (very) basic hints for beginners later in this section and these should be sufficient to get you going.
However, if you are going to make the best use of your Z88, you need to understand what you are doing.
Understanding does not come easily, but if you study the documentation and try things out for yourself you will be well rewarded.
Apart from sound and graphics, all the statements and functions specified for BBC BASIC are available.
BBCBASIC(Z80) has been designed to be as compatible as possible with Version 4 of the 6502 BBC BASIC resident in the BBC Micro Master series.
The language syntax is not always completely identical to that of the 6502 version, but in most cases the Z80 version is more tolerant.
Running BBCBASIC(Z80) 1.2
To run BBCBASIC(Z80) for the first time: Make sure the "Index" is displayed on your Z88.
(If necessary, press the <INDEX> key.)
Use the cursor keys to select "BASIC" from the application list.
Push the <ENTER> key.
After a couple of seconds, the system will reply: BBC BASIC (Z80) Version 3.00 (C) Copyright R.T.
Russell 1987 You can now start to use BBCBASIC(Z80).
If you have previously run BBCBASIC(Z80), you can return to it by using the cursor keys to select BASIC from the list of suspended activities in the index.
BBCBASIC(Z80) will appear exactly as you left it.
If you wish, you can have several instantiations (sessions or editions) of BBCBASIC.
Each instantiation will appear in the suspended activities list and you may use the cursor control keys to select the appropriate instantiation.
The easiest way to return to a suspended instantiation of BBCBASIC(Z80) by pressing <del>.
If you have more than one suspended instantiation of BBCBASIC(Z80), pressing <del> will return you to the earliest suspended instantiation.
Pressing <del> a second time will take you to the next earliest, and so on.
Within the space available, we can't go into details of what an operating system is, how programs run, etc.
Your Z88 user guide gives an explanation of how the Z88 works, what commands are available, how to run programs, etc — please read it.
GENERAL INFORMATION
INTRODUCTION 2.1
Control Codes and Functions 2.1.1
Generation 2.1.1.1
Control codes are generated by pressing the <del> key followed by another key.
You don't need to hold the <del> key down.
Thus "control A" is generated by pressing the <del> key followed by the "A" key.
Control "A" is shown as <del> A, etc.
In the immediate mode on BBC Micro, all control codes (with the exception of <Esc> and <del> U) are echoed to the micro's VDU software where they initiate the same functions as if they had been sent by the VDU statement.
This does not happen on the Z88.
In the immediate mode and in response to an INPUT statement, some control codes have a special significance to the input line editor (see later); with the exception of <ESCAPE>, the others are ignored.
All control codes and special function key codes are available to GET and GET$.
What Happens to Control Codes? 2.1.1.2
Pressing the <Esc> key aborts a program or command.
Pausing the Display 2.1.1.3
Holding down <del> and <SHIFT> will pause output to the screen.
Line Numbers
Line numbers up to 65535 are allowed.
If line 65535 does not exist, then GOTO 65535 is equivalent to END.
Line number 0 is not permitted.
When it is necessary to write more than one statement on a line, the statements may be separated by a colon ": " .
BBCBASIC(Z80) will tolerate the omission of the separator if this does not lead to ambiguity.
It's safer to leave it in and the program is easier to read.
Statement Separators 2.1.3
For example, the following program will work 
Editing 2.2
Introduction 2.2.1
The single line editor is active in the immediate mode and in response to an INPUT statement in a program.
The following editing keys are available when the single line editor is active.
The Program Editor 2.2.2
As described in the Z88 manual, you can use PipeDream to edit a BBCBASIC program.
This method is, however, a little long-winded if you only want to edit a couple of lines.
The single line editor is not available to BBCBASIC(Z80), but it is possible to include a line editing procedure in your BBCBASIC(Z80) programs.
The following program segment, which was developed by Cambridge Computer Ltd, provides the facilities of a line editor.
Once you have added the segment to your program, you can use it to edit program line "nnnn" with the command: PROCE(nnnn) The editing functions previously described are available when the line editing procedure is used.
To save entering the program segment for every program you write, create a file containing the program segment using PipeDream and save it in the plain text mode as EDBAS.
In this case, add.
J as the first line of the file.
The start of the program segment would then look like this:.
J 60010 DEF PROCE(B) 60020 REM Cambridge Computers Ltd. 60030 If B=0 THEN ENDPROC 60040 A=OPENOUT ": RAM.O/EE.CLI" You can append the editor to your BBCBASIC programs with the following command: *CLI. *EDBAS Your program should not, of course, use line numbers 60000 up.
If it does, they will be overwritten when you load the line editor.
To abort the single line editor and leave the line unchanged, press <ESC>.
As illustrated above, you can use PipeDream to write your BBCBASIC(Z80) programs.
You should save the program files in plain text format (you will get some interesting error messages if you don't).
Don't forget to include the CLI jammer command.
J as the first line of the file.
For complete (new) programs, you should include the BBCBASIC(Z80) command NEW as the second line of the file.
This will make sure that any program in memory will be deleted before the new one is loaded.
The first 2 lines of your PipeDream file will then look like this:.
J NEW If you saved the program to a file called BASPROG, you could load it into BBCBASIC(Z80) with the following command: *CLI. *BASPROG If you use PipeDream to write your program, you can arrange for the lines to be automatically numbered by BBCBASIC(Z80) as the file is "loaded" .
All you need to do is include the BBCBASIC(Z80) command, AUTO as the third line of your program file.
The first 3 lines of your PipeDream program file would now look like this:.
J NEW AUTO
Using PipeDream 2.2.3
Auto Numbering 2.2.3.1
Expression Priority
Order of Evaluation 2.3.1
The various mathematical and logical operators have a priority order.
The computer will evaluate an expression taking this priority order into account.
Operators with the same priority will be evaluated from left to right.
For example, in a line containing multiplication and subtraction, ALL the multiplications would be performed before any of the subtractions were carried out.
The various operators are listed below in priority order.
The following are some examples of the way expression priority can be used.
It often makes things easier for us humans to understand if you include the brackets whether the computer needs them or not.
IF A=2 AND B=3 THEN IF ((A=2) AND (B=3)) THEN IF A=1 OR C=2 AND B=3 THEN IF ((A=1) OR ((C=2) AND (B=3))) THEN IF NOT (A=1 AND B=2) THEN IF NOT (A=1) AND (B=2))) THEN N=A+B/C-D N=A+ (B/C) -D N=A/B+C/D N= (A/B) + (C/D)
Examples 2.3.2
Variables 2.4
Specification 2.4.1
Variable names may be of unlimited length and all characters are significant.
Variable names must start with a letter.
They can only contain the characters A…
Z, a…z, 0…9 and underline.
Embedded keywords are allowed.
Upper and lower case variables of the same name are different.
The following types of variable are allowed: A real numeric.
A% integer numeric.
A$ string.
Real variables have a range of <del> to <del> and numeric functions evaluate to 9 significant figure accuracy.
Internally every real number is stored in 40 bits (5 bytes).
The number is composed of a 4 byte mantissa and a single byte exponent.
An explanation of how variables are stored is given at Annex E.
Numeric Variables 2.4.2
Real Variables 2.4.2.1
Integer variables are stored in 32 bits and have a range of +2147483647 to -2147483648.
It is not necessary to declare a variable as an integer for advantage to be taken of fast integer arithmetic.
For example, FOR…
NEXT loops execute at integer speed whether or not the control variable is an "integer variable" (% type), so long as it has an integer value.
Integer Variables 2.4.2.2
The variables A%…
Z% are a special type of integer variable in that they are not cleared by the statements RUN, CHAIN and CLEAR.
In addition A%, B%, C%, D%, E%, F%, H% and L% have special uses in CALL and USR routines an P% and O% have a special meaning in the assembler (P% is the program counter and O% points to the code origin).
The special variable @% controls numeric print formatting.
The variables A%…
Z% and @% are called "static" , all other variables are called "dynamic" .
Static Variables 2.4.2.3
Boolean variables can only take one of the 2 values TRUE or FALSE.
Unfortunately, BBCBASIC does not have true boolean variables.
However, it does allow numeric variables to be used for logical operations.
The operands are converted to 4 byte integers (by truncation) before the logical operation is performed.
For example: Two numeric functions, TRUE and FALSE, are provided.
TRUE returns the value -1 and FALSE the value 0.
These values allow the logical operators (NOT, AND, EOR and OR) to work properly.
However, anything which is non-zero is considered to be TRUE.
This can give rise to confusion since +1 is considered to be TRUE and NOT(+1) is -2, which is also considered to be TRUE.
Boolean Variables 2.4.2.4
Numbers are stored in binary format.
Integers and the mantissa of real numbers are stored in 32 bits.
This gives a maximum accuracy of just over 9 decimal digits.
It is possible to display up to 10 digits before switching to exponential (scientific) notation (PRINT and STR$).
This is of little use when displaying real numbers because the accuracy of the last digit is suspect, but it does allow the full range of integers to be displayed.
Numbers up to the maximum integer value may be entered as a decimal constant without any loss of accuracy.
For instance, A%=2147483647 is equivalent to A%=&7FFFFFFF.
Numeric Accuracy 2.4.2.5
String variables may contain up to 255 characters.
An explanation of how variables are stored is given at the Annex entitled "Format of Program and Variables in Memory" .
String Variables and Garbage 2.4.3
Strings 2.4.3.1
Unlike numeric variables, string variables do not have a fixed length.
When you create a string variable, the memory used is sufficient for the initial value of the string.
If you subsequently assign a longer string to the variable there will be insufficient room for it and the string will have to occupy a different area in memory.
The initial area will then become "dead" .
These areas of "dead" memory are called garbage.
As more and more reassignments take place, the area of memory used for the variables grows and eventually there is no more room.
Several versions of BASIC have automatic "garbage collection" routines which tidy up the variable memory space when this occurs.
Unfortunately, this can take several seconds and can be embarrassing if your program is time conscious.
BBCBASIC does not incorporate "garbage collection" routines and it is possible to run out of room for variables even though there should be enough space.
Garbage Generation 2.4.3.2
You can overcome the problem of "garbage" by reserving enough memory for the longest string you will ever put into a variable before you use it.
You do this simply by assigning a string of spaces to the variable.
If your program needs to find an empty string the first time it is used, you can subsequently assign a null string to it.
The same technique can be used for string arrays.
The example below sets up a single dimensional string array with room for 20 characters in each entry, and then empties it ready for use.
Memory Allocation 2.4.3.3
Assigning a null string to stop$ prevents the space for the last entry in the array being recovered when it is emptied.
Arrays of integer, real and string variables are allowed.
All arrays must be dimensioned before use.
Integers, reals and strings cannot be mixed in a multi-dimensional array; you have to use one array for each type of variable you need.
Arrays 2.4.4
Program Flow Control 2.5
Introduction 2.5.1
When ever BBCBASIC(Z80) comes across a FOR, REPEAT, GOSUB, FN or PROC statement, it need to remember where it is in the program so that it can loop back or return there when it encounters a line with NEXT, UNTIL or RETURN statement or when it reaches the end of a function or procedure.
These "return addresses" tell BBCBASIC(Z80) where it is in the structure of your program.
Every time BBCBASIC(Z80) encountered a FOR, REPEAT, GOSUB, FN or PROC statement it "pushes" the return address on to a "stack" and every time it encountered a NEXT, UNTIL, RETURN statement or the end of a function or procedure it "pops" the latest return address of the stack and goes back there.
Unlike the BBC Micro, which has separate stacks for FOR…
NEXT, REPEAT…
UNTIL GOSUB…
RETURN and FN/PROC operations, BBCBASIC(Z80) uses a single control stack (the processor's hardware stack) for all looping and nesting operations.
The main effects of this difference are discussed below.
Apart from memory size, there is no limit to the level of nesting of FOR…
NEXT, REPEAT…
UNTIL and GOSUB…
RETURN operations.
The untrappable error message "No room" will be issued if all the stack space is used up.
Because a single stack is used, the following error messages do not exist.
Loop Operation Errors 2.5.2
Too many FORs Too many REPEATs Too many GOSUBs
The use of a common stack has one disadvantage (if it is a disadvantage) in that it forces stricter adherence to proper program structure.
It is not good practice to exit from a FOR…
NEXT loop without passing through the NEXT statement.
It makes the program more difficult to understand and the FOR address is left on the stack.
Similarly, the loop or return address is left on the stack if a REPEAT…
UNTIL loop or a GOSUB…
RETURN structure is incorrectly exited.
This means that if you leave a FOR…
NEXT loop without executing the NEXT statement, and then subsequently encounter, for example, a RETURN statement, BBCBASIC(Z80) will report an error.
(In this case, a "No GOSUB at line nnnn" error.)
The example below would result in the error message "No PROC at line 500" .
Program Structure Limitations 2.5.3
BBCBASIC(Z80) is a little unusual in detecting this error, but it is always risky.
It usually results in an inconsistent program structure and an unexpected "Too many FORs/REPEATs/GOSUBs" error on the BBC Micro when the control stack overflows.
There are a number of ways to leave a program loop which do not conflict with the need to write tidy program structures.
These are discussed below.
Leaving Program Loops 2.5.4
The simplest way to overcome the problem of exiting a FOR…
NEXT loop is to restructure it as a REPEAT…
UNTIL loop.
The example below performs the same function as the previous example, but exits the structure properly.
It has the additional advantage of more clearly showing the conditions which will cause the loop to be terminated.
REPEAT…
UNTIL Loops
A simple way of forcing an exit from a FOR…
NEXT loop is to set the loop variable to a value equal to the limit value and then GOTO to the NEXT statement.
alternatively, you could set the loop variable to a value greater than the limit (assuming a positive step), but in this case the value on exit would be different depending on why the loop was terminated.
(In some circumstances, this may be an advantage.)
The example below uses this method to exit from the loop.
Notice, however, that the conditions which cause the loop to terminate are less clear since they do not appear together.
Changing the Loop Variable 2.5.4.2
A less satisfactory way of exiting a FOR…
NEXT loop is to enclose the loop in a dummy outer loop and rely on BBCBASIC(Z80)'s ability to "pop" inner control variables off the stack until they match.
If you use this method you MUST include the variable name in the NEXT statement.
This method, which is demonstrated below, is very artificial and the conditions which cause the loop to terminate are unclear.
Popping the Inner Variable 2.5.4.3
Since local variables are also stored on the processor's stack, you cannot use a FOR…
NEXT loop to make an array LOCAL.
For example, the following program will give the error message "Not LOCAL at line 400" .
Local Variables 2.5.5
You can overcome this by fabricating the loop using an IF…
THEN statement as shown below.
This is probably the only occasion when the use of a single stack promotes poor program structure.
The program stack is initialised to begin at HIMEM and, because of this, you cannot change the value of HIMEM when there is anything on the stack.
As a result, you cannot change HIMEM from within a procedure, function, subroutine, FOR…
NEXT loop or REPEAT…
UNTIL loop.
Stack Pointer 2.5.6
Indirection 2.6
Introduction 2.6.1
Most versions of BASIC allow access to the computer's memory with the PEEK function and the POKE command.
Such access, which is limited to one byte at a time, is sufficient for setting and reading screen locations or "flags" , but it is difficult to use for building more complicated data structures.
The indirection operators provided in BBCBASIC(Z80) enable you to read and write to memory in a far more flexible way.
They provide a simple equivalent of PEEK and POKE, but they come into their own when used to pass data between CHAINed programs, build complicated data structures or for use with machine code programs.
There are 3 indirection operators: The examples that follow assume that a DIM statement has been used to reserves an area of memory and store the address of the first byte of the memory in a variable called "mem" .
See the keyword DIM for more details.
For example DIM mem 20 If you know what you are doing, you can use the indirection operators to access the Z88's system memory.
However, because of the sophistication of the operating system, THIS CAN BE DISASTROUS.
The Indirection Operators 2.6.2
The query operator accesses individual bytes of memory.
? M means "the contents of" memory location "M" .
The first example below write & 23 to memory location "mem" , the second example sets "number" to the contents of that memory location and the third examples prints the contents of that memory location.
Query 2.6.3
Byte Access 2.6.3.1
Thus, "?" provides a direction replacement for PEEK and POKE.
A byte variable, "? count" for instance, may be used as the control variable in a FOR…
NEXT loop and only one byte of memory will be used.
Query as a Byte Variable 2.6.3.2
The query (?) indirection operator works on one byte of memory.
The word indirection operator (!) works on 4 bytes (an integer word) of memory.
Thus!
M=&12345678 The string indirection operator ($) writes a string followed by a carriage-return (& od ) into memory starting at the specified address.
Do not confuse M$ with $M.
The former is the familiar string variable whilst the latter means "the string starting at memory location M" .
For example, $M= "abcdef" would load the ASCII characters A to F into addresses M to M+5 and & od into address M+6, and PRINT $M would print ABCDEF All the examples so far have used only one operand with the byte and word indirection operators.
Provided the left-hand operand is a variable (such as "memory" ) and not a constant, "?" and "!" can also be used as binary operators.
(In other words, they can be used with 2 operands.)
For instance, M? 3 means "the contents of memory location M plus 3" and M! 3 means "the contents of the 4 bytes starting at M plus 3" .
In the following example, the contents of memory location "mem" plus 5 is first set to & 50 and then printed.
Exclamation
Dollar 2.6.5
Use of Binary Operators 2.6.6
DIM mem 20 mem? 5=&50 PRINT mem? 5 Thus, The 2 examples below show how 2 operands can be used with the byte indirection operator (?) to examine the contents of memory.
The first example displays the contents of 12 bytes of memory from location "mem" .
The second example displays the memory contents for a real numeric variable.
(See the Annex entitled "Format of Program and Variables in Memory" for an explanation.)
10 DIM mem 20 20 FOR offset=O TO 12 30 PRINT -mem+offset, -mem? offset 40 NEXT Line 30 prints the memory address and the contents in hexadecimal format.
See the Annex entitled "Format of Program and Variables In Memory" for an explanation of this program.
Indirection operators can be used to create special data structures, and as such they are an extremely powerful feature.
For example, a structure consisting of a 10 character string, an 8 bit number and a reference to a similar structure can be constructed.
Power of Indirection Operators 2.6.7
If M is the address of the start of the structure then: Linked lists and tree structures can easily be created and manipulated in memory using this facility.
Operators and Special Symbols 2.7
The following list is a rather terse summary of the meaning of the various operators and special symbols used by BBCBASIC(Z80).
It is provided for reference purposes; you will find more detailed explanations elsewhere in this manual?
A unary and binary operator giving 8 bit indirection.
! A unary and binary operator giving 32 bit indirection.
"A delimiting character in strings.
Strings always have an even number of"in them.
 "may be introduced into a string by the escape convention" ".
# Precedes reference to a file channel number (and is not optional.
$ A character indicating that the object has something to do with a string.
The syntax  may be used to position a string anywhere in memory.
As a suffix on a variable name it indicates a string variable.
% A suffix on a variable name indicating an integer variable.
& Precedes hexadecimal constants e.g. &EF' A character which causes new lines in PRINT or INPUT.
() Objects in parentheses have highest priority.
= "Becomes" for LET statement and FOR, "result is" for FN, relation of equal to on integers, reals and strings.
— Unary negation and binary subtraction on integers and reals. * Binary multiplication on integers and reals; statement indicating operating system command (*DELETE).
: Multi-statement line statement delimiter.
; Suppresses forthcoming action in PRINT.
Comment delimiter in the assembler.
Delimiter in VDU and INPUT.
+ Unary plus and binary addition on integers and reals; concatenation between strings.
, Delimiter in lists…
Decimal point in real constants; abbreviation symbol on keyword entry; introduce label in assembler. < Relation of less than on integers, reals and strings.
/Binary division on integers and reals. \ Alternative comment delimiter in the assembler.
Relation of less than or equal on integers, reals and strings.
=> Relation of greater than or equal on integers, reals and strings.
<> Relation of not equal on integers, reals and strings.
[]Delimiters for assembler statements.
Statements between these delimiters may need to be assembled twice in order to resolve any forward references.
The pseudo operation OPT (initially 3) controls errors and listing.
∘ Binary operation of  exponentiation between integers and reals.
A character in the start of a print field indicating that the item is to be printed in hexadecimal.
Also used with STR$ to cause conversion to an hexadecimal string.
Keywords 2.8
Keywords are recognised before anything else.
(For example, DEG and ASN in DEGASN are recognised, but neither is recognised in ADEGASN.)
Consequently, you don't have to type a space between a keyword and a variable (but it does make it easier to read your program).
Although they are keywords, the names of pseudo variables such as PI, LOMEM, HIMEM, PAGE, TIME, etc, act as variables in that their names can form the first part of the name of another variable.
For example, if A is a variable than AB can also be a variable.
Similarly, the name PI is not recognised in the name PILE; they are both unique variable names.
However, PI%, PI$ etc. are not allowed.
Since variables named in lower case will never be confused with keywords, many programmers use upper case only for keywords.
Ninetythree out of the total of 123 keywords are not allowed in upper case at the start of a variable name (anything may be used in lower case).
Those keywords that are allowed are shown in bold type.
Graphics and sound commands are not available on the Z88.
These commands are shown in small italics.
If you use one of these command, a "Sorry, not implemented" error will be reported.
Since the keywords must be in upper case, you may wish to use the <CAPs LOCK> key to lock the letter keys to upper case (the default setting for BBCBASIC(Z80)).
Alternatively, you can invert the action of the <SHIFT> key so that unshifted letters are in upper case and shifted letters are in lower case.
Error Handling 2.9
Introduction 2.9.1
Type of Errors 2.9.1.1
Once you have written your program and removed all the syntax errors, you might think that your program is error free.
Unfortunately life is not so simple, you have only passed the first hurdle.
There are 2 kinds of errors which you could still encounter; errors of logic and run-time errors.
Errors of logic are where BBCBASIC(Z80) understands exactly what you said, but what you said is not what you meant.
Run-time errors are where something occurs during the running of the program which BBCBASIC(Z80) is unable to cope with.
For example, is quite correct and it will work for all values of A. But if B is zero, the answer is "infinity" .
BBCBASIC(Z80) has no way of dealing with "infinity" and it will report a "Division by zero" error.
There is no way that BBCBASIC(Z80) can trap errors of logic, since it has no way of understanding what you really meant it to do.
However, you can generally predict which of the run-time errors are likely to occur and include a special "error handling" routine in your program to recover from them.
Trapping Errors 2.9.1.2
Why would you want to take over responsibility for handling run-time errors? when BBCBASIC(Z80) detects a run-time error, it reports it and RETURNS TO THE COMMAND MODE.
When you write a program yourself, you know what you want it to do and you also know what it can't do.
If, by accident, you try to make it do something which could give rise to an error, you accept the fact that command mode.
However, when somebody else uses your program they are not blessed with your insight and they may find the program "crashing out" to the command mode without knowing what they have done wrong.
Such programs are called "fragile" .
You can protect your user from much frustration if you predict what these problems are likely to be and include an error handling routine.
In the example below, a "-ve root" error would occur if the number input was negative and BBCBASIC(Z80) would return to the command mode.
Reasons for Trapping Errors 2.9.1.3
Example run:
Error Trapping Command 2.9.2
The main command provided by BBCBASIC(Z80) for error trapping and recovery is: The ON ERROR command directs BBCBASIC(Z80) to execute the following command(s) on the same line when a trappable error occurs.
ON ERROR 2.9.2.1
If an error was detected in a program after this line had been executed, the message "Oh No!" would be printed and the program terminated.
As explained in the "Program Flow Control" sub-section, every time BBCBASIC(Z80) encounters a FOR, REPEAT, GOSUB, FN or PROC statement it "pushes" the return address on to a "stack" and every time it encounters a NEXT, UNTIL, RETURN statement or the end of a function or procedure it "pops" the latest return address of the stack and goes back there.
The program stack is where BBCBASIC(Z80) records where it is within the structure of your program.
When an error is detected by BBCBASIC(Z80), the stack is cleared.
Thus, you cannot just take any necessary action depending on the error and return to where you were because BBCBASIC(Z80) no longer knows where you were.
If an error occurs within a procedure or function, the value of any PRIVATE variables will be the last value they were set to within the procedure or function which gave rise to the error.
There are 2 functions, ERR and ERL, and one statement, REPORT, which may be used to investigate and report on errors.
Using these, you can trap out errors, check that you can deal with them and abort the program run if you cannot.
Error Reporting 2.9.3
ERR returns the error number (see the Annex entitled "Error Messages and Codes" ).
ERR 2.9.3.1
ERL returns the line number where the error occurred.
If an error occurs in a procedure or function call, ERL will return the number of the calling line, not the number of the line in which the procedure/function is defined.
If an error in a DATA statement causes a READ to fail, ERL will return the number of the line containing the READ statement, not the number of the line containing the DATA.
ERL 2.9.3.2
REPORT prints out the error string associated with the last error which occurred.
REPORT 2.9.3.3
Problems With Error Trapping 2.9.4
If there is an error in your ON ERROR statement, BBCBASIC(Z80) will go into an infinite loop.
<ESC> (which generates error code 27) will not break you out of this loop.
On most (single tasking) computers like the BBC Micro, you can escape from such a loop by pressing <BREAK> or turning the computer off.
Because the Z88 is a sophisticated computer which is capable of holding several programs in memory concurrently, this option has complications.
If there is an error in the error handling part of your program, you will end up in a "doom loop" .
Unless you take special precautions, you will need to perform a soft or hard reset to escape from this situation.
A hard reset will cause all the programs and data in RAM to be lost and a soft reset may possibly leave the computer in an unstable condition which will lead to an eventual software failure.
To overcome this problem, you should ALWAYS include a line similar to as the FIRST line of any error handling routine.
If you do so, you will be able to escape to the index from a "doom loop" by pressing the <INDEX> key.
If you try to return to your BBCBASIC(Z80) program, you will find yourself in the same situation as when you left it.
All you can do is to <del>KILL the offending BBCBASIC(Z80) instantiation.
You will lose your program, but everything else will be intact.
For example, The example below does not try to deal with errors, it just uses ERR, ERL and REPORT to tell the user about the error.
Its only advantage over BBCBASIC(Z80)'s normal error handling is that it gives the error number; it would probably not be used in practice.
As you can see from the second run, pressing <ESC> is treated as an error (number 17).
Error Trapping Examples 2.9.5
Example run: The example below has been further expanded to include error trapping.
The only "predictable" error is that the user will try a negative number.
Any other error is unacceptable, so it is reported and the program aborted.
Consequently, when <ESC> is used to abort the program, it is reported as an error.
However, a further test for ERR=17 could be included so that the program will halt on ESCAPE without an error being reported.
Example run: The above example is very simple and was chosen for clarity.
In practice, it would be better to test for a negative number before using SQR rather than trap the "—ve root" error.
A more realistic example is the evaluation of a user-supplied HEX number, where trapping "Bad hex" would be much easier than testing the input string beforehand.
Procedures and Functions 2.10
Introduction 2.10.1
Procedures and functions are similar to subroutines in that they are "bits" of program which perform a discrete function.
Like sub routines, they can be performed (called) from several places in the program.
However, they have 2 great advantages over subroutines: you can refer to them by name and the variables used within them can be made private to the procedure or function.
Arguably, the major advantage of procedures and functions is that they can be referred to by name.
Consider the 2 similar program lines below.
The first statement gives no indication of what the subroutines at 500 and 800 actually do.
The second, however, tells you what to expect from the 2 procedures.
This enhanced readability stems from the choice of meaningful names for the 2 procedures.
A function often carries out a number of actions, but it always produces a single result.
For instance, the "built in" function INT returns the integer part of its argument.
A procedure on the other hand, is specifically intended to carry out a number of actions, some of which may affect program variables, but it does not directly return a result.
Whilst BBCBASIC(Z80) has a large number of predefined functions (INT and LEN for example) it is very useful to be able to define your own to do something special.
Suppose you had written a function called FN_discount to calculate the discount price from the normal retail price.
You could write something similar to the following example anywhere in your program where you wished this calculation to be carried out.
It may seem hardly worth while defining a function to do something this simple.
However, functions and procedures are not confined to single line definitions an they are very useful for improving the structure and readability of your program.
The names of procedures and functions MUST start with PROC or FN and, like variable names, they cannot contain spaces.
(A space tells BBCBASIC(Z80) that it has reached the end of the word.)
This restriction can give rise to some pretty unreadable names.
However, the underline character can be used to advantage.
Consider the procedure and function names below and decide which is the easier to read.
Names 2.10.2
Function and procedure names may end with a "$" .
However, this is not compulsory for functions which return strings.
Functions and procedure definitions are "signalled" to BBCBASIC(Z80) by preceding the function or procedure name with the keyword "DEF" .
DEF must be at the beginning of the line.
If the computer encounters DEF during execution of the program, the rest of the line is ignored.
Consequently, you can put single line definitions anywhere in your program.
Defining Functions and Procedures 2.10.3
Starting a Definition 2.10.3.1
The "body" of a procedure or function must not be executed directly — it must be performed (called) by another part of the program.
Since BBCBASIC(Z80) only skips the rest of the line when it encounters DEF, there is a danger that the remaining lines of a multi-line definition might be executed directly.
You can avoid this by putting multi-line definitions at the end of the main program text after the END statement.
Procedures and functions do not need to be declared before they are used and there is no speed advantage to be gained by placing them at the start of the program.
The Function/Procedure Body 2.10.3.2
The end of a procedure definition is indicated by the keyword "ENDPROC" .
The end of a function definition is signalled by using a statement which starts with n equals (=) sign.
The function returns the value of the expression to the right of the equals sign.
Ending a Definition 2.10.3.3
For single line definitions, the start and end are signalled on the same line.
The first example below defines a function which returns the average of 2 numbers.
The second defines a procedure which clears from the current cursor position to the end of line on an 80 column screen.
Single Line Functions/Procedures 2.10.3.4
You can define a whole library of procedures and functions and include them in your programs.
By doing this you can effectively extend the scope of the language.
For instance, BBCBASIC(Z80) does not have a "clear to end of screen" command.
Some computers will perform this function on receipt of a sequence of control characters and in this case you can use VDU or CHR$ to send the appropriate codes.
However, many computers do not have this facility and a procedure to clear to the end of the screen would be useful.
The example below is a procedure to clear to the end of screen on a computer with an 94 by 8 display.
In order to prevent the display from scrolling, you must not write to the last column of the last row.
The 3 variables used (i, x, and y) are declared as LOCAL to the procedure (see later).
Extending the Language 2.10.3.5
When you define a procedure or a function, you list the parameters to be passed to it in brackets.
For instance, the discount example expected one parameter (the retail price) to be passed to it.
You can write the definition to accept any number of parameters.
For example, we may wish to pass both the retail price and the discount percentage.
The function definition would then look something like this: In this case, to use the function we would need to pass 2 parameters.
Passing Parameters 2.10.4
The value of the first parameter in the line using the procedure or function is passed to the first variable named in the parameter list in the definition, the second to the second, and so on.
This is termed "passing by value" .
The parameters declared in the definition are called "formal parameters" and the values passed in the lines which perform (call) the procedure or function are called "actual parameters" .
There must be as many actual parameters passing as there are formal parameters declared in the definition.
You can pass a mix of string an numeric parameters to the same procedure or function and a function can return either a string or numeric value, irrespective of the type of parameters passed to it.
However, you must make sure that the parameter types match up.
The first example below is correct; the second would give rise to an "Arguments at line 10" error message and the third would cause a "Type mismatch at line 10" error to be reported.
Formal and Actual Parameters 2.10.4.1
You can use the statement LOCAL to define variables which are only known locally to individual procedures and functions.
In addition, formal parameters are local to the procedure or function declaring them.
These variables are only known locally to the defining procedure or function.
They are not known to the rest of the program and they can only be changed from within the procedure or function where they are defined.
Consequently, you can have 2 variables of the same name, say FLAG, in various parts of your program, and change the value of one without changing the other.
This technique is used extensively in the example file handling programs in the second part of this manual.
Local Variables 2.10.5
Declaring variables as local, creates them locally and initialises them to zero/null.
Variables which are not formal variables or declares as LOCAL are known to the whole program, including all the procedures and functions.
Such variables are called GLOBAL.
Because the formal parameters which receive the passed parameters are local, all procedures and functions can be reentrant.
That is, they can call themselves.
But for this feature, the short example program below would be very difficult to code.
It is the often used example of a factorial number routine.
(The factorial of a number n is n*n-1 *n-2*…*1.
Factorial 6, for instance, is 6*5*4*3*2*1)
Reentrant Functions/Procedures 2.10.5.1
Since "n" is the input variable to the function it is local to each and every use of the function.
The function keeps calling itself until it returns the answer 1.
It then works its way back through all the calls until it has completed the final multiplication, when it returns the answer.
The limit of 35 on the input number prevents the answer being too big for the computer to handle.
Assembler
Introduction 3.1
BBCBASIC(Z80) has an Z80 assembler.
This assembler is similar to the 6502 assembler on the BBC Micro.
This section illustrates the way the BBCBASIC(Z80) assembler functions; it does not provide sufficient information to enable you to write assembler programs that interface with the Z88 operating system or hardware.
In order to successfully write assembler language programs for the Z88 you will need a considerable amount of technical information about the machine.
This information may be obtained from Cambridge Computer Ltd.
The Z88 is a sophisticated computer which is capable of holding several programs in memory concurrently.
This makes incorrectly written assembler language programs potentially dangerous.
Whilst the Z88's operating system is quote robust, you could cause the Z88 to enter an undefined state if your program does not correctly interface with it.
If this happens, you may corrupt all the data and programs in RAM and you will need to perform a soft or hard reset.
A hard reset will cause all the programs and data in RAM to be lost and there is a possibility that a soft reset may leave the computer in an unstable condition which will lead to an eventual soft-ware-failure.
If you wish to develop assembler language programs, we suggest you do so on a computer which does not hold programs or data that you cannot afford to lose.
It would also be wise to download your program to another computer or an EPROM before testing it.
If you do not take these precautions, you may eventually lose some irreplaceable programs or data.
BBCBASIC(Z80) Z80 assembler is entered in the same way as the BBC Micro 6502 assembler.
That is, "[" enters assembler mode and "]" exists assembler mode.
Entering the Assembler 3.1.1
All standard Zilog mnemonics are accepted, "ADD" , "ADC" and "SBC" must be followed by "A" or "HL" .
For example, The brackets around the port numbers in "IN" and "OUT" are optional.
Thus, both are acceptable.
Mnemonics 3.1.2
The pseudo-operations "DEFB" , "DEFW" and "DEFM" are included.
 "DEFM" is like "EQUS" in the 6502 version.
The instruction "IN F,(C) is not accepted, but the equivalent object code is produced from" IN (HL),(C)".
An assembly language statement consists of 3 elements; an optional label, an instruction and an operand.
A comment may follow the operand field.
The instruction following a label must be separated from it by at least one space.
Similarly, the operand must also be separated from the instruction by a space.
Assembler Statements 3.1.3
Statements are terminated by a colon (:) or end of line (<ENTER>).
Any BBCBASIC(Z80) numeric variable may be used as a label.
These (external) labels are defined by an assignment (count=23 for instance).
Internal labels are defined by preceding them with a full stop.
When the assembler encounters such label, a BASIC variable is created containing the current value of the Program Counter (P%).
(The Program Counter is described later.)
Labels 3.1.4
In the example shown later under the heading "The Assembly Process" , 2 internal labels are defined and used.
Labels have the same rules as standard BBCBASIC(Z80) variable names; they should start with a letter and not start with a keyword.
You can insert comments into assembly language programs by preceding them with a semi-slash (\).
In assembly language, a comment ends at the end of the statement.
Thus, the following example will work (but it's a bit untidy).
You can store constants within your assembly language program using the define byte (DEFB), define word (DEFW) and define message (DEFM) pseudo-operation commands.
These will create 1byte, 2byte and "string" items respectively.
Comments 3.1.5
Byte, Word and String Constants 3.1.6
DEFB can be used to set one byte of memory to a particular value.
For example, will set 2 consecutive bytes of memory to 15 and 9 (decimal).
The address of the first byte will be stored in the variable "data" .
DEFW can be used to set 2 bytes of memory to a particular value.
The first byte is set to the least significant byte of the number and the second to the most significant byte.
For example, will have the same result as the Byte Constant example.
Define Byte — DEFB 3.1.6.1
Byte Constant 3.1.6.1.1
Define Word — DEFW 3.1.6.2
DEFM can be used to load a string of ASCII characters into memory.
For example, will load the string "This is a test message" followed by a carriage-return into memory.
The address of the start of the message is loaded into the variable "string" .
This is equivalent to the following program segment: Unfortunately, there is no "define storage" directive.
A second DIM statement may be used, or, for small amounts of storage, you can use DEFM with a dummy string.
For example will reserve 100 bytes of storage.
String Constant — DEFM 3.1.6.2.1
Define Storage 3.1.6.2.2
Reserving Memory 3.2
The Program Counter 3.2.1
Machine code instructions are assembled as if they were going to be placed in memory at the addresses specified by the program counter, P%.
Their actual location in memory may be determined by O% depending on the OPTion specified (see below).
You must make sure that P% (or O%) is pointing to a free area of memory before your program begins assembly.
In addition, you need to reserve the area of memory that your machine code program will use so that it is not overwritten at run time.
You can reserve memory by using a special version of the DIM statement or by moving HIMEM down (see later).
Using the special version of the DIM statement to reserve an area of memory is the simplest way for short programs which do not have to be located at a particular memory address.
(See the keyword DIM for more details.)
For example, will reserve 21 bytes of code (byte 0 to byte 20) and load the variable "code" with the start address of the reserved area.
You can then set P% (or O%) to the start of that area.
The example below reserves an area of memory 100 bytes long and sets P% to the first byte of the reserved area.
Using DIM to Reserve Memory 3.2.2
If you are going to use a machine code program in a number of your BBCBASIC(Z80) programs, the simplest way is to assemble it once, save it using PROC_save (described later) and load it from each of your programs using PROC_load (described later).
In order for this to work, the machine code program must be loaded into the same address each time.
The most convenient way to arrange this is to move HIMEM down by the length of the program and load the machine code program in to this protected area.
Theoretically, you could raise LOMEM to provide a similar protected area below your BBCBASIC(Z80) program.
However, altering LOMEM destroys ALL your dynamic variables and is more risky.
Moving HIMEM to Reserve Memory 3.2.3
You must reserve an area of memory which is sufficiently large for your machine code program before you assemble it, but you may have no real idea how long the program will be until after it is assembled.
How then can you know how much memory to reserve?
Unfortunately, the answer is that you can't. however, you can add to your program to find the length used and then change the memory reserved by the DIM statement to the correct amount.
Length of Reserved Memory 3.2.4
In the example below, a large amount of memory is initially reserved.
To begin with, a single pass is made through the assembly code and the length needed for the code is calculated (lines 100 to 120).
After a CLEAR, the correct amount of memory is reserved (line 140) and a further 2 passes of the assembly code are performed as usual.
Your program should not, of curse, subsequently try to use variables set before the clear statement.
If you use a similar structure to the example and place the program lines which initiate the assemble function at the start of your program, you can place your assembly code anywhere you like and still avoid this problem.
The program counters, P% and O% are initialised to zero.
Using the assembler without first setting P% (and O%) is liable to corrupt the operating system.
Initial setting of the Program Counter 3.2.5
The Assembly Process 3.3
OPT 3.3.1
The only assembly directive is "OPT" .
As with the 6502 assembler, "OPT" controls the way the assembler works, whether a listing is displayed and whether errors are reported.
OPT should be followed by a number in the range 0 to 7.
The way the assembler functions is controlled by the 3 bits of this number in the following manner.
Bit 0 controls the listing.
If it is set, a listing is displayed.
Bit 0 — LSB 3.3.1.1
Bit 1 controls the error reporting.
If it is set, errors are reported.
Bit 1 3.3.1.2
Bit 2 controls where the assembled code is placed.
If bit 2 is set, code is placed in memory starting at the address specified by O%.
However, the program counter (P%) is still used by the assembler for calculating the instruction addresses.
Bit 2 3.2.1.3
In general, machine code will only run properly if it is in memory at the addresses for which it was assembled.
Thus, at first glance, the option of assembling it is a different area of memory is of little use.
However, using this facility, it is possible to build up a library of machine code utilities for use by a number of programs.
The machine code can be assembled for a particular address by one program without any constraints as to its actual location in memory and saved using PROC_ save.
This code can then be loaded into its working location from a number of different programs using PROC_load.
(PROC_save and PROC_load are described later in this section)
Assembly at a Different Address 3.3.2
The code is assembled using the program counter (P%) to calculate the instruction addresses and the code is also placed in memory at the address specified by the program counter.
OPT Summary 3.3.3
Code Assembled Starting at P% 3.3.3.1
The code is assembled using the program counter (P%) to calculate the instruction addresses.
However, the assembled code is placed in memory at the address specified by O%.
Code Assembled Starting at O% 3.3.3.2
How the Assembler Works 3.3.4
The assembler works line by line through the machine code.
When it finds a label declared it generates a BBCBASIC(Z80) variable with that name and loads it with the current value of the program counter (P%).
This is fine all the while labels are declared before they are used.
However, labels are often used for forward jumps and no variable with that name would exist when it was first encountered.
When this happens, a "No such variable" error occurs.
If error reporting has not been disabled, this error is reported and BBCBASIC(Z80) returns to the direct mode in the normal way.
If error reporting has been disabled (OPT 0,1,4 or 5), the current value of the program counter is used in place of the address which would have been found in the variable, and assembly continues.
By the end of the assembly process the variable will exist (assuming the code is correct), but this is of little use since the assembler cannot "backtrack" and correct the errors.
However, if a second pass is made through the assembly code, all the labels will exist as variables and errors will not occur.
The example below shows the result of 2 passes through (completely futile) demonstration program.
Twelve bytes of memory are reserved for the program.
(If the program was run, it would "doom-loop" from line 50 to 70 and back again).
The program disables error reporting by using OPT 1.
This is the first pass through the assembly process.
This is the second pass through the assembly process.
Generally, if labels have been used, you must make 2 passes through the assembly language code to resolve forward references.
This can be done using a FOR…
NEXT loop.
Normally, the first pass should be with OPT O (or OPT 4) and the second pass with OPT 2 (OPT 6).
If you want a listing, use OPT 3 (OPT7) for the second pass.
During the first pass, a table of variables giving the address of the labels is built.
Labels which have not yet been included in the table (forward references) will generate the address of the current op-code.
The correct address will be generated during the second pass.
Saving and Loading Machine Code Programs 3.3.5
As mentioned earlier, you can use machine code routines in a number of BBCBASIC(Z80) programs by using PROC save and PROC load.
The safest way to do this is to write a program which consists of only the machine code routines and enough BBCBASIC(Z80) to assemble them.
They should be assembled "out of the way" at the top of memory (each routine starting at a known address) and then PROC_saved.
(Don't forget to move HIMEM down first).
The BBCBASIC(Z80) programs that use these routines should move HIMEM down to the same value before they PROC_load the assembly code routines into the address at which they were originally assembled.
PROC_save and PROC_load are listed below.
Save an area of memory to a file.
You MUST specify the start address (aaa) and the length of the area of memory (lll).
PROC_save and PROC_load 3.3.5.1
Using PROC_save 3.3.5.2
Load the specified file into memory at hexadecimal address "aaaa" .
The load address MUST always be specified.
Using PROC_load 3.3.5.3
Conditional Assembly and Macros 3.4
Introduction 3.4.1
Most machine code assemblers provide conditional assembly and macro facilities.
The assembler does not directly offer these facilities, but it is possible to implement them by using other features of BBCBASIC(Z80).
You may wish to write a program which makes use of special facilities and which will be run on different types of computer.
The majority of the assembly code will be the same, but some of it will be different.
In the example below, different output routines are assembled depending on the value of "flag" .
Conditional Assembly 3.4.2
Within any machine code program it is often necessary to repeat a section of code a number of times and this can become quite tedious.
You can avoid this repetition by defining a macro which you use every time you want to include the code.
The example below uses a macro to pass a character to the screen or printer.
Conditional assembly is used within the macro to select either the screen or the auxiliary output depending on the value of op_flag.
Macros 3.4.3
It is possible to suppress the listing of the code in macro by forcing bit 0 of OPT to zero for the duration of the macro code.
This can most easily be done by ANDing the value passed to OPT with 6.
This is illustrated in PROC_screen and PROC_aux in the example below.
The use of a function call to incorporate the code provides a neat way of incorporating the macro within the program and allows parameters to be passed to it.
The function should return the original value of OPT.
Errors on the Z88 3.4.4
Warning 3.4.4.1
If you write an application which contains bugs or tries to circumnavigate the operating system, then it is likely that all the other applications in the Z88 will be affected.
The effect may not be immediate, some indiscretions take weeks or even months to become apparent, but will usually be in the form of a system crash.
You must always remember that the resources of the Z88 are not devoted exclusively to your application and therefore only use legal interfaces.
All the internal applications follow all the rules and use no "back door" techniques.
If you wish to write more than the simplest assembler code programs for the Z88, you will need a considerable amount of technical information about the machine.
This information is available from Cambridge Computer Ltd.
If your assembler language program makes any use at all of the Z88's facilities.
it will be possible to suspend it.
Under these circumstances, it is imperative that your program includes error handling code.
Error Handling 3.4.4.2
The following assembler language "wrap around" provides the minimum acceptable error handling capability.
The "wrap around" recognises and acts on the following events: An escape condition (the <ESCAPE> key having been pressed whilst escape detection is enabled).
The <INDEX> key having been pressed.
The key having been pressed.
The process having been killed.
You may wish to develop your own error handler, but you should always use one.
If you don't, you could run into trouble.
You can test the error handling code by including the following program as the "main" routine.
Try running the complete program and observe the effect of: Suspending (<INDEX>) and then either killing or reentering.
Pressing <ESCAPE>.
Switching the Z88 off and on (both <SHIFT> keys).
Statements and Functions
Introduction 4.1
The commands and statements are listed alphabetically for ease of reference, they are not separated into 2 sections.
All statements can also be used as direct commands.
Where appropriate, the abbreviated form is shown to the right of the statement.
The associated keywords are listed at the end of each explanation.
If the lexical analyser tries to expand a line to more than 255 characters, a "Line space" error will be reported.
Abbreviated definitions for the commands and statements in BBCBASIC(Z80) are given at the end of the explanation for each keyword.
Most of us have seen formal syntax diagrams and Backus-Naur Form (BNF) definitions for languages, and many of us have been found them to be somewhat confusing.
Consequently, we have attempted to produce something which, whilst being reasonably precise, is readable by the majority of BBCBASIC(Z80) users.
To those amongst you who would have preferred "the real thing" — we apologise.
Syntax 4.1.1
ABS
A function giving the absolute value of its argument.
This function converts negative numbers into positive ones.
It can be used to give the difference between 2 numbers without regard to the sign of the answer.
It is particularly useful when you want to know the difference between 2 values, but you don't know which is the larger.
For instance, if X=6 and Y=10 then the following examples would give the same result.
You can use this function to check that a calculated answer is within certain limits of a specified value.
For example, suppose you wanted to check that "answer" was equal to "ideal" plus or minus (up to ) 0.5.
One way would be: However the following example would be a more elegant solution.
ACS
A function giving the arc cosine of its argument in radians.
The permitted range of the arguments is -1 to +1.
If you know the cosine of the angle, this function will tell you the angle (in radians).
Unfortunately, you cannot do this with complete certainty because 2 angles within the range +/-PI (+/-180 degrees) can have the same cosine.
This means that one cosine has 2 associated angles.
The following diagram illustrates the problem.
Within the 4 quadrants, there are 2 angles which have the same cosine, 2 with the same sine and 2 with the same tangent.
When you are working back from the cosine, sine or tangent you don't know which of the 2 possible angles is correct.
By convention, ACS gives a result in the top 2 quadrants (0 to PI-0 to 180 degrees) and ASN and ATN in the right-hand 2 quadrants (-PI/2 to +PI/2 — -90 to +90 degrees).
In the example below, "radian_angle" becomes equal to the angle (in radians) whose cosine is "y" .
You can convert the answer to degrees by using the DEG function (or multiplying by 180/PI).
ADVAL
Not available on the Z88 The operation of integer bitwise logical AND between 2 items.
The 2 operands are internally converted to 4 byte integers before the AND operation.
You can use AND as a logical operator or as a "bit-by-bit" (bitwise) operator.
The operands can be boolean (logical) or numeric.
In the following example program segment, AND is used as a bitwise operator to remove the most significant bit of a byte read from a file before writing it to another file.
This is useful for converting some word-processor files into standard ASCII format.
Unfortunately, BBCBASIC does not have true boolean variables; it uses numeric variables and assigns the value 0 for false and -1 for TRUE.
This can lead to confusion at times.
(See NOT for more details).
In the example below, the operands are boolean (logical).
In other words, the result of the tests (IF) A=2 and (IF) B=3 is either TRUE or FALSE.
The result of this example will be TRUE if A=2 and B=3.
The brackets are not necessary, they have been included to make the example easier to follow.
The second example is similar to the first, but in the more familiar surroundings of a IF statement.
or The final example, uses the AND in a similar fashion to the numeric operators (+,-, etc).
Suppose X was -20, the AND operation would be:
ASC
A function returning the ASCII character value of the first character of the argument string.
If the string is null then -1 will be returned.
A computer only understands numbers, In order to deal with characters, each character is assigned a code number.
For example(in the ASCII code table) the character "A" is given the code number 65 (decimal).
A part of the computer generates special electronic signals which cause the characters to be displayed on the screen.
The signals generated vary according to the code number.
Different types of computer use different numbers for the characters.
The codes used for PC compatible computers are those defined by the American Standard Code for Information Interchange (ASCII).
A list of the ASCII codes is at Annex A.
You could use this function to convert ASCII codes to some other coding scheme.
ASC is the complement of CHR$
ASN
A function giving the arc sine of its argument in radians.
The permitted range of the argument is -1 to +1.
By convention, the result will be in the range -PI/2 to +PI/2 (-90 to +90 degrees).
If you know the sine of the angle, this function will tell you the angle (in radians).
Unfortunately, you cannot do this with complete certainty because one sine has 2 associated angles.
(See ACS for details.)
In the example below, "radian_angle" becomes equal to the angle (in radians) whose sine is "y" .
You can convert the answer to degrees by using the DEG function.
(The DEG function is equivalent to multiplying by 180/PI).
the example below is similar to the first one, but the angle is in degrees.
ATN
A function giving the arc tangent of its argument in radians.
The permitted range of the argument is from — to + infinity.
By convention, the result will be in the range -PI/2 to +PI/2 (-90 to +90 degrees).
If you know the tangent of the angle, this function will tell you the angle (in radians).
As the magnitude of the argument (tangent) becomes very large (Approaches + or — infinity) the accuracy diminishes.
In the example below, "radian_angle" becomes equal to the angle (in radians) whose tangent is "y" .
You can convert the answer to degrees by using the DEG function.
(The DEG function is equivalent to multiplying by 180/PI.) the example below is similar to the first one, but the angle is in degrees.
ATO
A command allowing the user to enter lines without first typing in the number of the line.
The line numbers are preceded by the usual prompt (>).
You can use this command to tell the computer to type the line numbers automatically for you when you are entering a program (or part of a program).
If AUTO is used on its own, the line numbers will start at 10 and go up by 10 for each line.
However, you can specify the start number and the value by which the line numbers will increment.
The step size can be in the range 1 to 225.
You cannot use the AUTO command within a program or a multi-statement command line.
You can leave the AUTO mode by pressing the escape key.
A hyphen is an acceptable alternative to a comma.
BGET# B.#
A function which gets a byte from the data file whose file handle is its argument.
The file pointer is incremented after the byte has been read.
You must have opened a file using OPENOUT, OPENIN or OPENUP before you use this statement.
(See these keywords and the"BBCBASIC(Z80) Files' section for details.)
You can use the BGET# to read single bytes from a file.
This enables you to read back small integers which have been "packed" into less than 5 bytes (see BPUT#).
It is also very useful if you need to perform some conversion operation on a file.
Each byte read is numeric, but you can use CHR$ (BGET#n) to convert it to a string.
The input file in the example below is a text file produced by a word-processor.
Words to be underlined are "bracketed" with ∘S The program produces an output file suitable for a printer which expects such words to be bracketed by ∘Y.
You could, of course, perform several such translations in one program.
To make the program more useful, it could ask for the names of the input and output files at "run time" .
BPUT# BP. #
A statement which puts a byte to the data file whose file handle is the first argument.
The second argument's least significant byte is written to the file.
The file pointer is incremented after the byte has been written.
Before you use this statement you must have opened a file or output using OPENOUT or OPENUP.
(See these keywords and the "BBCBASIC(Z80) Files" section for details.)
You can use this statement to write single bytes to a file.
The number that is sent to the file is in the range 0 to 225.
Real numbers are converted internally to integers and the top 3 bytes are "masked off" .
Each byte written is numeric, but you can use ASC (character$) to convert (the first character of) "character$" to a number.
The example below is a program segment that "packs" an integer number between 0 and 65535 (& ffff ) into 2 bytes, least significant byte first.
The file must have already been opened for output and the file handle stored in "fnum" .
The integer variable number% contains the value to be written to the file.
CALL CA.
A statement to call a machine code subroutine.
The processor's A, B, C, D, E, F, H, and L registers are initialised to the least significant words of A%, B%, C%, D%, E%, F%, H%, and L% respectively (see also USR).
CALL sets up a table in RAM containing details of the parameters.
The IX register is set to the address of this parameter table.
The IY register is set to the address of the machine code subroutine being called.
Parameter Table
Variables included in the parameter list need not have been declared before the CALL statement.
The parameter types are: On entry to the subroutine the parameter table contains the following values: Except it the case of a movable string (normal string variable), the parameter address given is the absolute address at which the item is stored.
In the case of movable strings (type 129), it is the address of a parameter block containing the current length, the maximum length and the start of the string, in that order.
<para.
Integer variables are stored in twos complement format with their least significant byte first.
Parameter Formats
Fixed strings are stored as the characters of the string followed by a carriage return (& 0d ).
Floating point variables are stored in binary floating point format with their least significant byte first.
The fifth byte is the exponent.
The mantissa is stored as a binary fraction in sign and magnitude format.
Bit 7 of the most significant byte is the sign bit and, for the purposes of calculating the magnitude of the number, this bit is assumed to be set to one.
The exponent is stored as a positive integer in excess 127 format.
(To find the exponent subtract 127 from the value in the fifth byte.
If the exponent of a floating point number is zero, the number is stored in integer format in the mantissa.
If the exponent is not zero, then the variable has a floating point value.
Thus, an integer can be stored in 2 different formats in a real variable.
For example, 5 can be stored as In the case of a movable string (normal string variable), the parameter address points to the "string descriptor" .
This descriptor gives the current length of the string, the number of bytes allocated to the string (the maximum length of the string) and the address of the start of the string (LSB first).
See the Annex entitled "Format of Program and Variables in Memory" for details of how parameters are stored.
CHAIN CH.
A statement which loads and runs the program whose name is specified in the argument.
The program file must be in tokenised format.
All but the static variables @% to Z% are CLEARed.
CHAIN sets ON ERROR OFF before chaining the specified program.
RUN may be used as an alternative to CHAIN.
You can use CHAIN (or RUN) to link program modules together.
This allows you to write modular programs which would, if written in one piece, be too large for the memory available.
Passing data between CHAINed programs can be a bit of a problem because COMMON variables cannot be declared and all but the static variables are cleared by CHAIN.
If you wish to pass large amounts of data between CHAINed programs, you should use a data file.
Because the Z88's files are held in RAM, the time penalty for using a data file is minimal.
If the amount of data to be passed is small, you may prefer to pass data to the CHAINed program by using the indirection operators to store them at known addresses.
The safest way to do this is to move HIMEM down and store common data at the top of memory.
The following sample program segment moves HIMEM down 100 bytes and stores the input and output file names in the memory above HIMEM.
There is, of course, still plenty of room for other data in this area.
Remember, do not suspend BBCBASIC(Z80) before the next program is CHAINed
CHR$
A function which returns a string of length 1 containing the ASCII character specified by the least significant byte of the numeric argument.
CHR$ generates an ASCII character (symbol, letter, number character, control character, etc) from the number given.
The number specifies the position of the generated character in the ASCII table (See Annex A).
For example: will set char$ equal to character "A" .
You can use CHR$ to send a special character to the terminal or printer.
(Generally, VDU is better for sending characters to the screen).
For example, will generate the ASCII character BEL (G).
So, will print the message "ERROR" and sound the keyboard's "bell" .
CHR$ is the complement of ASC.
CLEAR CL.
A statement which clears all the dynamically declared variables, including strings.
CLEAR does not affect the static variables.
The CLEAR command tells BBCBASIC(Z80) to forget about ALL the dynamic variables used so far.
This includes strings and arrays, but the static variables (A% to Z% and @%) are not altered.
You can use the indirection operators to store integers and strings at known addresses an these will not be affected by CLEAR> However, you will need to "protect" the area of memory used.
The easiest way to do this is to move HIMEM down.
See CHAIN for an example.
CLOSE# CLO.
A statement used to close a data file.
You use CLOSE# to tell BBCBASIC(Z80) that you have completely finished with a file or device for this phase of the program.
Any data still in the file buffer is written to the file before the file is closed.
CLOSE#0 closes all files open in the current instantiation of BBCBASIC(Z80).
You can open and close a file several times within one program, but it is generally considered "better form" not to close a file until you have finally finished with it.
However, if you wish to CLEAR the variables, it is simpler if you close the data files first.
You should also close data files before chaining another program.
CHAIN does not automatically close data files, but it does clear the variables in which the file handles were stored.
You can still access the open file if you used one of the static variables (A% to Z%) to store the file handle.
END or "dropping off" the end of a program will also close all open data files.
However, STOP does not close data files.
CLG
Not available on the Z88 A statement which clears the text area of the screen.
The cursor is moved to the "home" position (0,0) at the top left-hand corner of the text area.
COLOUR (COLOR)
Not available on the Z88 A function giving the cosine of its radian argument.
This function returns the cosine of an angle.
The angle must be expressed in radians, not degrees.
Whilst the computer is quite happy dealing with angles expressed in radians, you may prefer to express angles in degrees.
You can use the RAD function to convert an angle from degrees to radians.
The example below sets Y to the cosine of the angle "degree_angle" expressed in degrees.
COUNT COU.
A function returning the number of characters sent to the display since the last new line.
Characters with an ASCII value of less than 13 (carriage return/new-line/enter) have no effect on COUNT.
Because control characters above 13 are included in COUNT, you cannot reliably use it to find the position of the cursor on the screen.
If you need to know the cursor's horizontal position use the POS function.
The example below prints strings from the string array "words$" .
The strings are printed on the same line until the line length exceeds 65.
When the line length is in excess of 65, a new-line is printed.
DATA D.
A program object which must precede all lists of data for use by the READ statement.
As for INPUT, string values may be quoted or unquoted.
However, quotes need to be used if the string contains commas or leading spaces.
Numeric values may include calculation so long as there are no keywords.
Data items in the list should be separated by a comma.
You can use DATA in conjunction with READ to include data in your program which you may need to change from time to time, but which does not need to be different every time you run the program.
The following example program segment reads through a list of names looking for the name in"name$.
If the name is found, the name and age are printed.
If not, an error message is printed.
DEF
A program object which must precede declaration of a user defined function (FN) or procedure (PROC).
DEF must be used at the start of a program line.
If DEF is encountered during execution, the rest of the line is ignored.
As a consequence, single line definitions can be put anywhere in the program.
Multi-line definitions must not be executed.
The safest place to put multi-line definitions is at the end of the main program after the END statement.
There is no speed advantage to be gained by placing function or procedure definitions at the start of the program.
In order to make the text more readable (always a GOOD THING) the function or procedure name may start with an underline.
Function and procedure names may end with a "$" .
This is not compulsory for functions which return strings.
A procedure definition is terminated by the statement ENDPROC.
A function definition is terminated by a statement which starts with an equals (=) sign.
The function returns the value of the expression to the right of the equals sign.
For examples of function and procedure declarations, see FN and PROC.
For a general explanation of functions and procedures, refer to the "Procedures and Functions' sub-section in the" General Information"section.
DEG
A function which converts radians to degrees.
You can use this function to convert an angle expressed in radians to degrees.
One radian is approximately 57 degrees (actually 180/PI).
PI/2 radians is 90 degrees and PI radians is 180 degrees.
Using DEG is equivalent to multiplying the radian value by 180/PI, but the result is calculated internally to a greater accuracy.
See ACS, ASN and ATN for further examples of the use of DEG.
DELETE DEL.
A command which deletes a group of lines from the program.
Both start and end lines of the group will be deleted.
You can use delete to remove a number of lines from you program.
To delete a single line, just type the line number followed by <Enter>.
The example below deletes all the lines between line 10 and 15(inclusive).
To delete from a given line to the end of the program, use 65535 as the last line number.
To delete from line 2310 to the end of the program, type: A hyphen is an acceptable alternative to a comma.
DIM
There are 2 quite different uses for the DIM statement: the first dimensions an array and the second reserves an area of memory for special applications.
The DIM statement is used to declare arrays.
Arrays must be pre-declared before use and they must not be redimensioned.
Both numeric and string arrays may be multi dimensional.
Dimensioning Arrays
After DIM, all elements in the array are 0/null.
The subscript base is 0, so DIMX (12) defines an array of 13 elements.
Arrays are like lists or tables.
A list of names is a single dimension array.
In other words, there is only one column — the names.
Its single dimension in a DIM statement would be the maximum number of names you expected in the table less 1.
If you wanted to describe the position of the pieces on a chess board you could use a 2 dimensional array.
The 2 dimensions would represent the row (numbered 0 to 7) and the column (also numbered 0 to 7).
The contents of each "cell" of the array would indicate the presence (if any) of a piece and its value.
Such an array would only represent the chess board at one moment of play.
If you wanted to represent a series of board positions you would need to use a 3 dimensional array.
The third dimension would represent the "move number" .
Each move would use about 320 bytes of memory, so you could record 40 moves in about 12.5k bytes.
A DIM statement is used to reserve an area of memory which the interpreter will then not use.
The variable in the DIM statement is set by BBCBASIC(Z80) to the start address of this memory area.
This reserved area can be used by the indirection operators, machine code, etc.
Reserving an Area of Memory
DIM reserves memory from the current position to the current position + the number used in the DIM statement.
Thus, reserves 4 bytes of memory (? x, x? 1, x? 2 and x? 3).
A "DIM space" error will occur if a size of less than -1 is used (DIM P%-2).
DIM P%-1 is a special case; it reserves zero bytes of memory.
This is of more use than you might think, since it tells you the limit of the dynamic variable allocation.
Thus, is the equivalent of PRINT FREE(0) in some other versions of BASIC.
See also EXT#-1.
See the "Assembler" section for a more detailed description of the use of DIM for reserving memory for assembly code programs.
DIV
A binary operation giving the integer quotient of two items.
The result is always an integer.
You can use this function to give the "whole number" part of the answer to a division.
For example.
would give 5 (with a "remainder" of 1).
Whilst it is possible to use DIV with real numbers, it is really intended for use with integers.
If you do use real numbers, BBCBASIC(Z80) converts them to integers by truncation before DIViding them.
DRAW
Not available on the Z88
EDIT E.
Not available on the Z88 See the "Editing" sub-section of the "General Information" section for information about editing BBCBASIC(Z80) programs.
A statement delimiter which provides an alternative course of action in IF…
THEN, ON…
GOSUB/GOTO statements.
In an IF statement, if the test is FALSE, the statements after ELSE will be executed.
This makes the following work: In a multi statement line containing more than one IF, the statement(s) after the ELSE delimiter will be actioned if ANY of the tests fail.
For instance, the example below would print the error message "er$" if "x" did not equal 3 OR if "a" did not equal "b" .
If you want to "nest" the tests, you should use a procedure call.
The following example, would print "Bad" ONLY if x was equal to 3 AND "a" was not equal to "b" .
ELSE also traps exceptions in ON.
You can use ELSE with ON…
GOSUB/GOTO statements to prevent an out of range control variable causing an ON range error.
END
A statement causing the interpreter to return to direct mode.
There can be any number( >=0); of END statements anywhere in a program.
END closes all open files.
END tells BBCBASIC(Z80) that it has reached the end of the program.
You don't have to use END, just "running out of program" will have the same effect, but it's a bit messy.
You can use END within, for instance, an IF…
THEN…
ELSE statement to stop your program if certain conditions are satisfied.
You should also use END to stop BBCBASIC(Z80) "running into" any procedure or function definitions at the end of your program.
ENDPROC
A statement denoting the end of a procedure.
All local variables and the dummy arguments are restored at ENDPROC and the program returns to the statement after the calling statement.
ENVELOPE
No available on the Z88
EOF#
A function which will return -1 (TRUE) if the data file whose file handle is the argument is at, or beyond, its end.
In other words, when PTR# points beyond the current end of the file.
When reading a serial file, EOF# would go true when the last byte of the file had been read.
EOF# is only true if PTR# is set beyond the last byte written to the file.
It will NOT be true of an attempt has been made to read from an empty block of a sparse random access file.
Because of this, it is difficult to tell which records of a random access file have had data written to them.
These files need to be initialised and the unused records marked as empty.
Writing to a byte beyond the current end of file updates the file length immediately, whether the record is physically written at that time or not.
However, the file must be closed in order to ensure that all the data written to it is physically written away to the file.
If you attempt to read beyond the current end of the file, you will get an "END of file" error.
In an unexpected Z88, BBCBASIC(Z80) has a workspace of 8 Kbytes.
In an expanded Z88 (containing at least 128 Kbytes in slot 1) the workspace is increased to 40 Kbytes.
EOF#-1 returns TRUE for an expanded machine and FALSE for an unexpanded machine.
EOR
The operation of bitwise integer logical exclusive-or between 2 items.
The 2 operands are internally converted to 4 byte integers before the EOR operation.
EOR will return a non-zero result if the 2 items are different.
You can use EOR as a logical operator or as a "bit-by-bit" (bitwise) operator.
The operands can be boolean (logical) or numeric.
Unfortunately, BBC BASIC does not have true boolean variables; it uses numeric variables and assigns the value 0 for FALSE and -1 for TRUE.
This can lead to confusion at times.
(See NOT for more details.)
In the example below, the operands are boolean (logical) and the result of the tests (IF) A=2 and (IF) B=3 is either TRUE or FALSE.
The result of this example will be FALSE if A=2 and B=3 or A<>2 and B<>3.
In other words, the answer will only be TRUE if the results of the 2 tests are different.
The brackets are not necessary, they have been included to make the example easier to follow.
The last example uses EOR in a similar fashion to the numeric operators (+,-, etc).
Suppose X was -20, the EOR operation would be:
ERL
A function returning the line number of the line where the last error occurred.
If there was an error in a procedure call, the line number of the calling line would be returned, not the line number of the definition.
The number returned by ERL is the line number printed out when BBCBASIC(Z80) reports an error.
See the "Error Handling" sub-section for more information on error handling and correction.
ERR
A function returning the error code number of the last error which occurred (see the Annex entitled "Error Messages and Codes" ).
Once you have assumed responsibility for error handling using the ON ERROR statement, you can use this function to discover which error occurred.
See the "Error Handling" sub-section for more information on error handling and correction.
EVAL EV.
A function which applies the interpreter's expression evaluation program to the characters held in the argument string.
In effect, you pass the string to BBCBASIC(Z80)'s evaluation program and say "work this out" .
You can use this function to accept and evaluate an expression, such as a mathematical equation, whilst the program is running.
You could, for instance, use it in a "calculator" program to accept and evaluate the calculation you wished to perform.
Another use would be in a graph plotting program to accept the mathematical equation you wished to plot.
The example below is a"bare bones' calculator program which evaluates the expression typed in by the user.
You can only use EVAL to work out functions like SIN, COS, etc, including user defined functions.
It won't execute statements like PRINT, etc.
In the following example, EVAL would print "Hello word!" if you entered "FN_FRED" in response to the prompt.
The program will continue until an error occurs.
(Pressing <ESC>. for example.)
Example run (user entry in bold):
EXP
A function returning "e" to the power of the argument.
The argument must be <88.7228392.
The "natural" number, "e" , is 2.71828183.
This function can be used as the "anti-log" of a natural logarithm.
Logarithms are "traditionally" used for multiplication (be adding the logarithms) and division (by subtracting the logarithms).
For example, will calculate 2.5*2 by adding their natural logarithms and print the answer.
EXT#
A function which returns the total length of the file whose file handle is its argument.
In the case of a sparse random-access file, the value returned is the complete file length from byte zero to the last byte written.
This may well be greater than the actual amount of data in the file, but it is the amount of space allocated to the file by the Z88's operating system.
The file must have been opened before EXT# can be used to find its length.
EXT#-1 returns an estimate of the amount of free memory.
See the Annex entitled "Format of Program and Variables in Memory" for more details.
Free memory is available to the device: RAM.
-, and to applications (such as PipeDream), but not necessarily to the filing system.
Consequently, you cannot reliably use EXT#-1 to discover how much space is left in the current filing system device (: RAM.0, for example).
FALSE
A function returning the value zero.
BBCBASIC(Z80) does not have true Boolean variables.
Instead, numeric variables are used and their value is interpreted in a "logical" manner.
A value of zero is interpreted as FALSE and NOT FALSE (in other words, NOT 0) is interpreted as TRUE.
In practice, any value other than zero is considered TRUE.
You can use FALSE in a REPEAT…
UNTIL loop to make the loop repeat for ever.
Consider the following example.
Since "terminator" will never be zero, the result of the test "terminator=0" will always be FALSE.
Thus, the following example has the same effect as the previous one.
Similarly, since FALSE=0, the following example will also have the same effect, but its meaning is less clear.
See the keyword AND for logical tests and their results.
FN
A keyword used at the start of all user declared functions.
The first character of the function name can be an underline (or a number)
If there are spaces between the function name and the opening bracket of the parameter list (if any) they must be present both in the definition and the call.
It's safer not to have spaces between the function name and the opening bracket.
A function may be defined with any number of parameters of any type, and may return (using =) a string or numeric result.
It does not have to be defined before it is used.
A function definition is terminated by "=" used in the statement position.
The following examples show the "=" as part of a program line and at the start of a line.
The first 2 examples are single line function definitions.
Functions are reentrant and the parameters arguments) are passed by value.
You can write single line, multi statement functions so long as you have a colon after the definition statement.
The following function sets the print control variable to the parameter passed and returns a null string.
It may be used in a PRINT command to change the print control variable @%) within a print list.
Functions have to return an answer, but the value returned by this function is a null string.
Consequently, its only effect is to change the print control variable.
Thus the PRINT statement will print X in G9z10 format and Y in F2z10 format.
See the keyword PRINT for print format details.
FOR
A statement initialising a FOR…
NEXT loop.
the loop is executed at least once.
The FOR…
NEXT loop is a way of repeating a section of program a set number of times.
For example, the 2 programs below perform identically, but the second is easier to understand.
You can GOTO anywhere within one FOR…
NEXT loop, but not outside it.
This means you can't exit the loop with a GOTO.
You can force a premature end to the loop by setting the control variable to a value equal to or greater than the end value (assuming a positive STEP).
It is not necessary to declare the loop variable as an integer type in order to take advantage of fast integer arithmetic.
If it is an integer, then fast integer arithmetic is used automatically.
see Annex E for an explanation of how BBCBASIC(Z80) recognises an integer value of a real variable.
Any numeric assignable item may be used as the control variable.
In particular, a byte variable (?
X) may act as the control variable and only 1 byte of memory will be used.
See the Indirection sub-section for details of the indirection operators.
Because a single stack is used, you cannot use a FOR…
NEXT loop to set array elements to LOCAL in a procedure or function.
GCOL G.C
Not available on the Z88
GET/GETS#
A function and compatible string function that reads the next character from the keyboard buffer (it waits for the character).
GET and GET$ wait for a "key" (character) to be present in the keyboard buffer and then return the ASCII number of the key (see Annex A) or a string containing the character of the key.
If there are any characters in the keyboard buffer when a GET is issued, then a character will be returned immediately.
See the keyword INKEY for a way of emptying the keyboard buffer before issuing a GET.
GET and GET$ do not echo the pressed key to the screen.
If you want to display the character for the pressed key, you must PRINT it.
You can use GET and GET$ whenever you want your program to wait for a reply before continuing.
For example, you may wish to display several screens of instructions and allow the user to decide when he has read each screen.
The values returned by the cursor control and other "special" keys are listed below.
Many of the keys return 2 bytes, a "zero" byte followed by another value.
GET can also be used to input data from I/O port.
Full 16-bit port addressing is available.
This is an addition to the original language specification and it cannot be guaranteed to remain unchanged in future releases.
GOSUB
A statement which calls a section of a program (which is a subroutine) at a specified line number.
One subroutine may call another subroutine (or itself).
The only limit placed on the depth of nesting is the room available for the stack.
You may calculate the line number.
However, if you do, the program should not be RENUMBERed.
A calculated value must be placed in brackets.
Very often you need to use the same group of program instructions at several different places within your program.
It is tedious and wasteful to repeat this group of instructions every time you wish to see them.
You can separate this group of instructions into a small sub-program.
This sub-program is called a subroutine.
The subroutine can be "called" by the main program every time it is needed by using the GOSUB statement.
At the end of the subroutine, the RETURN statement causes the program to return to the statement after the GOSUB statement.
Subroutines are similar to PROCedures, but they are called by line number not by name.
This can make the program difficult to read because you have no idea what the subroutine does until you have followed it through.
You will probably find that PROCedures offer you all the facilities of subroutines and, by choosing their names carefully, you can make your programs much more readable.
GOTO
A statement which transfers program control to a line with a specified or calculated line number.
You may not GOTO a line which is outside the current FOR…
NEXT, REPEAT…
UNTIL or GOSUB loop.
If a calculated value is used, the program should not be RENUMBERed.
A calculated value must be placed in brackets.
The GOTO statement makes BBCBASIC(Z80) jump to a specified line number rather than continuing with the next statement in the program.
You should use GOTO with care.
Uninhibited use will make your programs almost impossible to understand (and hence, debug).
If you use REPEAT…
UNTIL and FOR…
NEXT loops you will not need to use many GOTO statements.
HIMEM
A pseudo-variable which contains the address of the first byte that BBCBASIC(Z80) will not use.
HIMEM must not be changed within a subroutine, procedure, function, FOR…
NEXT or REPEAT…
UNTIL loop.
BBCBASIC(Z80) uses the computer's memory to store your program and the variables that your program use.
The default value of HIMEM is the highest memory address available for use by BBCBASIC(Z80).
On an expanded machine (one containing at least 128 Kbytes of RAM in slot 1) HIMEM is initially set to & c000 .
On an unexpanded machine, it is set to & 4000 .
In an unexpanded Z88, BBCBASIC(Z80) has a workspace of 8 Kbytes.
In an expanded Z88 the workspace is increased to 40 Kbytes.
If you want to change HIMEM, you should do so early in your program.
Once it has been changed it will stay at its new value until set to another value.
Thus, if you wish to load a machine code subroutine for use by several programs, you only have to change HIMEM and load the subroutine once.
See the "Assembler" section and the keyword CHAIN for more details.
USE WITH CARE
IF
A statement which sets up a test condition which can be used to control the subsequent flow of the program.
It is part of the IF…
THEN…
ELSE structure.
The word THEN is optional under most circumstances.
The IF statement is the primary decision making statement.
The testable condition (A=B, etc) is evaluated and the answer is either TRUE or FALSE.
If the answer is TRUE, the rest of the line (up to the ELSE clause if there is one) is executed.
The "=" sign has 2 meanings.
It can be used to assign a value to a variable or as part of a test.
The example shows the 2 uses in one program line.
In English this reads "A becomes equal to the result of the test B=C" .
Thus if B does equal C, A will be set to TRUE (-1).
However, if B does not equal C, A will be set to FALSE (0).
The example below is similar, but A will be set to TRUE (-1) if "age" is less than 21.
Since the IF statement evaluates the testable condition and acts on the result, you can use a previously set variable name in place of the test.
The 2 examples below will print "Under 21" if the value of "age" is less than 21.
INKET and INKEY$
A function and compatible string function which does a GET/GET$, waiting for a maximum of "num" clock ticks of 10 ms each.
If no key is pressed in the time limit, INKEY will return -1 and INKEY$ will return a null string.
The INKEY function will return the ASCII value of the key pressed.
A table of ASCII values is included at Annex A and the values returned by the function and other special keys are tabulated below.
You can use this function to wait for a specified time for a key to be pressed.
A key can be pressed at any time before INKEY is used.
Pressed keys are stored in an input buffer.
Since INKEY and INKEY$ get a character from the normal input stream, you may need to empty the input buffer before you use them.
You can do this with the following program line.
The number in brackets is the number of "ticks" (one hundredths of a second) which BBCBASIC(Z80) will wait for a key to be pressed.
after this time, BBCBASIC(Z80) will give up and return -1 or a null string.
The number of"ticks' may have any value between 0 and 32767.
INKEY with a negative argument is not available on the Z88.
INPUT
A statement to input values from the console input device (usually keyboard).
If items are not immediately preceded by a printable prompt string (even if null) then a "?" will be printed as a prompt.
If the variable is not separated from the prompt string by a comma, the "?" is not printed.
In other words: no comma — no question mark.
Items A, B, C, D$ in the above example can have their answer returned on one to four lines, separate items being separated by commas.
Extra items will be ignored.
Then WHO ARE YOU? is printed (the question mark comes from the comma) and W$ is input, then NAME is printed and R$ is input (no comma — no "?" ).
When the <Enter> key is pressed to complete an entry, a new-line is generated.
BBCBASIC has no facility for suppressing this new-line, but the TAB function can be used to reposition the cursor.
For example, will position the cursor at column 0 of line 5 and print the prompt Name?.
After the name has been entered the cursor will be positioned at column 20 on the same line and Age? will be printed.
When the age has been entered the cursor will move to the next line.
The statement is exactly equivalent to Leading spaces will be removed from the input line, but not trailing spaces.
If the input string is not completely numeric, it will make the best it can of what it is given.
If the first character is not numeric, 0 will be returned.
Neither of these 2 cases will produce an error indication.
Consequently, your program will not abort back to the command mode if a bad number is input.
You may use the EVAL function to convert a sting input to a numeric and report an error if the string is not a proper number or you can include your own validation checks.
Stings in"ed form are taken as they are, with a possible error occurring for a missing closing quote.
A semicolon following a prompt string is an acceptable alternative to a comma.
INPUT LINE
A statement of identical syntax to INPUT which uses a new line for each item to be input.
The item input is taken as is, including commas, quotes and leading spaces.
INPUT#
A statement which reads data in internal format from a file and puts them in the specified variables.
It is possible to read past the end-of-file without an error being reported.
You should always include some form of check for the end of the file.
READ# can be used as an alternative to INPUT#
Whilst BBCBASIC(Z80) stores numbers in internal format, text is stored in the usual way as a string of characters followed by a carriage-return.
Consequently, you can use the INPUT command to read text from, say a PipeDream file.
See the"BBCBASIC(Z80) Files' section for more details and numerous examples of the use of INPUT#.
INSTR
A function which returns the position of a sub-string within a string, optionally starting the search at a specified place in the string.
The leftmost character position is 1.
If the sub-string is not found, 0 is returned.
The first string is searched for any occurrence of the second string.
There must not be any spaced between INSTR and the opening bracket.
You can use this function for validation purposes.
If you wished to test A$ to see if was one of the set "FRED BERT JIM JOHN" , you could use the following: The character used to separate the items in the set must be excluded from the characters possible in A$.
One way to do this is to make the separator an unusual character, say CHR$ (127).
INT
A function converting a real number to the lower integer.
This function converts a real number (one with a decimal part) to the nearest integer (whole number) less than the number supplied.
Thus
LEFT$
A string function which returns the left "num" characters of the string.
If there are insufficient characters in the source string, all the characters are returned.
There must not be any spaces between LEFT$ and the opening bracket.
LEN
A function which returns the length of the argument string.
This function "counts" the number of characters in a string.
For example, would set "length" to 15 since the sting consists of the 12 characters of BBCBASIC(Z80) followed by 3 spaces.
LEN is often used with a FOR…
NEXT loop to "work down" a string doing something with each letter in the string.
For example, the following program looks at each character in a string and checks that it is a valid hexadecimal numeric character.
LET
Let is an optional assignment statement.
LET is not permitted in the assignment of the pseudo-variables LOMEM, HIMEM, PAGE, PTR# and TIME.
LET was mandatory on early versions of BASIC.
Its use emphasised that when we write we don't mean to state that X equals X+4 — it can't be, but rather "let X become equal to what it was plus 4." 
Most modern versions of BASIC allow you to drop the "LET" statement.
However, if you are writing a program for a novice, the use of LET makes it more understandable.
LIST
A command which causes lines of the current program to be listed out to the screen with the automatic formatting options specified by LISTO.
A hyphen is an acceptable alternative to a comma.
The listing may be paused by pressing the <del> and <SHIFT> keys together.
With the standard CLI active, the screen output will halt at the end of each page until the Space-bar is pressed.
Escape will abort the listing.
LIST may be included within a program, but it will exit to the command mode on completion of the listing.
LISTO
A command which controls the appearance of a LISTed program.
The command controls the setting of the 3 least significant bits of the format control byte which can, therefore, be set to an integer 0 to 7 (0=all3 bits 0, 7=all 3 bits 1).
If Bit 0 is set, a space will be printed between the line number and the remainder of the line.
(All leading spaces are stripped when the line is originally entered.)
Bit settings
Bit 0 (LSB)
If Bit 1 is set, 2 extra spaces will be printed out on lines between FOR and NEXT.
Two extra spaces will be printed for each depth of nesting.
Bit 1
If Bit 2 is set 2 extra spaces will be printed out on lines between REPEAT and UNTIL.
Two extra spaces will be printed for each depth of nesting.
Bit 2
The default setting of LISTO is 7.
This will give a properly formatted listing.
The indentation of the FOR…
NEXT and REPEAT…
UNTIL lines is done in the correct manner, in that the NEXT is aligned with the FOR and the REPEAT with the UNTIL.
LN
A function giving the natural logarithm of its argument.
This function gives the logarithm to the base "e" of its argument.
The "natural" number, "e" is 2.71828183.
Logarithms are "traditionally" used for multiplication (be adding the logarithms) and division (by subtracting the logarithms).
For example, will calculate 2.5*2 by adding their natural logarithms and print the answer.
LOAD
A command which loads a new program from a file and CLEARs the variables of the old program.
The program file must be in "internal" (tokenised) format.
File names must conform to the standard Z88 format.
If no device and/or path are given, the current device and/or path are assumed.
See the "Operating System Interface" section for a more detailed description of valid file names.
You use LOAD to bring a program in a file into memory.
The keyword LOAD should be followed by the name of the program file.
If the program file is in the current directory, only the file name needs to be given.
If the program is not in the current directory, its full device, path and file name must be specified.
For example: would load the program "demo" from the directory"bbcprogs' on device: RAM.0.
LOCAL
A statement to declare variables for local use inside a function (FN) or procedure (PROC).
A null list of variables is not permitted.
LOCAL saves the values of its arguments in such a way that they will be restored at "=" or ENDPROC.
If a function or a procedure is used recursively, the LOCAL variables will be preserved at each level.
The LOCAL variables are initialised to zero/null.
LOG
A function giving the base-10 logarithms of its argument.
Thus function calculates the common (base 10) logarithm of its argument.
Inverse logarithms (anti-logs) can be calculated by raising 10 to the power of the logarithm as shown below.
Logarithms are "traditionally" used for multiplication (by adding the logarithms) and division (by subtracting the logarithms).
For example,
LOMEM
A pseudo-variable which controls where in memory the dynamic data structures are to be placed.
The default is TOP, the first free address after the end of the program.
Normally, dynamic variables are stored in memory immediately after your program.
(See the Annex entitled "Format of Program and Variables in Memory" ).
You can change the address where BBCBASIC(Z80) starts to store these variables by changing LOMEM.
USE WITH CARE.
Changing LOMEM in the middle of a program causes BBCBASIC(Z80) to lose track of all the variables you are using.
MID$
A string function which returns "num" characters of the string starting from character "start_posn" .
If "num" is not present or if there are insufficient characters in the string, then all the characters from "start_posn" onwards are returned.
You can use this function to select any part of a string.
For instance if If the last number is omitted or there are insufficient characters to the right of the specified position, MID$ returns with the right hand part of the string starting at the specified position.
Thus, would print
MOD
A binary operation giving the signed remainder of the integer division.
MOD is defined such that, If you are doing integer division (DIV) of whole numbers it is often desirable to know the remainder.
(A "teach children to divide" program for instance.)
For example, 23 divided by 3 is 7, remainder 2.
Thus You can use real numbers in these calculations, but they are truncated to their integer part before BBCBASIC(Z80) calculates the result.
Thus, would give exactly the same results as the previous example.
MODE
Not available on the Z88
MOVE
Not available on the Z88
NEW
A command which initialises the interpreter for a new program to be typed in.
The old program may be recovered with the OLD command provided no new program lines have been typed in or deleted and no variables have been created.
This command effectively "removes" a program from the computer's memory.
In reality the program is still there, but BBCBASIC(Z80) has been told to forget about it.
If you have made a mistake, you can recover your old program by typing OLD.
However, this won't work if you have begun to enter a new program.
NEXT N.
The statement delimiting FOR…
NEXT loops.
NEXT takes an optional control variable If the control variable is present then FOR…
NEXT loops may be "popped" automatically in an attempt to match the correct FOR statement.
(This should not be necessary.)
If a matching FOR statement cannot be found, a "Can't match FOR" error will be reported.
Leaving out the control variable will make the program run quicker, but this is not to be encouraged.
See the keyword FOR for more details about the structure of FOR…
NEXT loops.
NOT
This is a high priority unary operator (the same priority as unary —).
It causes a bit-by-bit binary inversion of the numeric to its right.
The numeric may be a constant, a variable, or a mathematical or boolean expression.
Expressions must be enclosed in brackets.
NOT is most commonly used in an IF…
THEN…
ELSE statement to reverse the effect of the test.
BBCBASIC(Z80) does not have true boolean variables; it makes do with numeric variables.
This can lead to confusion because the testable condition in an IF…
THEN…
ELSE statement is evaluated mathematically and can result in something other than -1 (TRUE) or 0 (FALSE).
When the test in an IF…
THEN…
ELSE is evaluated, FALSE=0 and anything else is considered to be TRUE.
if you wish to use NOT to reverse the action of an IF statement it is important to ensure that the testable condition does actually evaluate to -1 for TRUE.
If the testable condition evaluates to 1, for example, the result of the test would be considered to be TRUE and the THEN part of the IF…
THEN…
ELSE statement would be carried out.
However, using NOT in front of the testable condition would not reverse the action.
NOT 1 evaluates to -2, which would also be considered to be TRUE.
OLD
A command which undoes the effect of NEW provide no lines have been typed in or deleted, and no variables have been created.
ON
A statement controlling a multi-way switch.
The line numbers in the list may be constants or calculated and the "unwanted" ones are skipped without calculation.
The ON statement is used in conjunction with 4 other key-words: GOTO, GOSUB, PROC and ERROR.
(ON ERROR is explained separately.)
The ON statement alters the path through your program by transferring control to one of a selection of line numbers depending on the value of a variable.
For example, would send your program to line 1000 if "number" was 1, to line 2000 if "number" was 2, to line 500 if "number" was 3 and to line 100 if "number" was 4.
Exceptions may be trapped using the ELSE statement delimiter.
If there is no statement after the ELSE, the program will "dropthrough" to the following line if an exception occurs.
In the 2 following examples, the program would drop through to the error handling part of the program if "choice" or "B-46" was less than 1 or more than 3.
You can use ON…
GOTO, ON…
GOSUB, and ON…
PROC to execute the appropriate part of your program as the result of a menu selection.
The following skeleton example offers a menu with 3 choices.
If a statement terminator (: or the token for ELSE) appears within the line, the interpreter assumes that the ON…statement is terminated.
For example, you cannot pass a colon as a literal string parameter in an ON…
PROC command.
The program line would be interpreted as and give rise to an interesting crop of error messages.
Limitations
ON ERROR
A statement controlling error trapping.
If an ON ERROR statement has been encountered, BBCBASIC(Z80) will transfer control to it (without taking any reporting action) when n error is detected.
This allows error reporting/recovery to be controlled by the program.
however, the program control stack is still cleared when the error is detected and it is not possible to RETURN to the point where the error occurred.
ON ERROR OFF returns the control of error handling to BBCBASIC(Z80).
If there is an error in your error handling routine, your program will enter a loop.
Unless you take the precaution described below, the only way to escape from this is with a soft or hard reset.
You can avoid having to perform a reset by including a line such as: at the beginning of your error handling routine.
you can then exit from BBCBASIC(Z80) by pressing the <INDEX> key and <del>KILL the offending instantiation of BBCBASIC(Z80).
Error handling is explained more fully in the "General Information" section.
OPENIN OP.
A function which opens a file (or device) for reading and returns the file handle of the file.
This number must be used in subsequent references to the file with BGET#, INPUT# EXT#, PTR#, EOF# or CLOSE#.
A returned value of zero signifies that the specified file was not found on the specified (or default) device.
The example below reads data into an array.
If the data file does not exist, an error message is printed and the program ends.
You can also use OPENIN to access the devices: COM.0, etc.
See the "Operating System Interface" and "BBCBASIC(Z80) Files" sections for more details.
OPENOUT OPENO.
A function which opens a file (or device) for writing and returns the file handle of the file.
This number must be used in subsequent references to the file with BPUT#, PRINT#, EXT#, PTR# or CLOSE#.
You can also read from a file which has been opened using OPENOUT.
This is of little use until you have written some data to it.
However, once you have done so, you can move around the file using PTR# and read back previously written data.
Data is not written to the file at the time it is opened.
Consequently, it is possible to successfully open a file on a full device.
Under these circumstances, a "Device full" error would be reported when you tried to write data to the file for the first time.
The example below writes the contents of 2 arrays (tables) to a file called "TOPTEN" You can also use OPENOUT to access the devices: COM.O,: PTR.O, etc.
See the "Operating System Interface" and "BBCBASIC(Z80) Files" sections for more details.
OPENUP
A function which opens a file (or device) for update (reading and writing) and returns the file handle of the file.
This number must be used in subsequent references to the file with BGET#, BPUT#, INPUT#, PRINT#, EXT#, PTR#, EOF# or CLOSE#.
A returned value of zero signifies that the specified file was not found on the specified (or default) device.
See the random file example (F—RANDO) in the "BBCBASIC(Z80) Files" section for examples of the use of OPENUP.
You can also use OPENUP to access the devices: COM.0, etc.
See the "Operating System Interface" and "BBCBASIC(Z80) Files" sections for more details.
OPT
An assembler pseudo operation controlling the method of assembly.
(See the "Assembler" section for more details.)
OPT is followed by an expression with the following meanings: Code Assembled Starting at P% Code Assembled Starting at 0% The possible assembler errors are: Out of range — error code 40.
No such variable — error code 26.
OR
The operation of bitwise integer logical OR between two items.
The 2 operands are internally converted to 4 byte integers before the OR operation.
You can leave out the space between OR and a preceding constant, but it makes your programs difficult to read.
You can use OR as a logical operator or as a "bit-by-bit" (bitwise) operator.
The operands can be boolean (logical) or numeric.
Unfortunately, BBC BASIC does not have true boolean variables; it uses numeric variables and assigns the value 0 for FALSE and -1 for TRUE.
This can lead to confusion at times.
(See NOT for more details.)
In the example below, the operands are boolean (logical).
In other words the result of the tests (IF) A=2 and (IF) B=3 is either TRUE or FALSE.
The result of this example will be TRUE if A=2 or B=3.
The brackets are not necessary, they have been included to make the example easier to follow.
The last example, uses the OR in a similar fashion to the numeric operators (+,-, etc).
Suppose X was -20 in the following example, the OR operation would be:
OSCLI
This command allows a string expression to be passed to the operating system.
It overcomes the problems caused by the exclusion of variables in the star (*) commands.
Using this statement, you can, for instance, erase and rename files whose names you only know at run-time.
If the command is not recognised by the Z88's operating system, a "Bad command" error will be reported.
PAGE PA.
A pseudo-variable controlling the starting address of the current user program area.
It addresses the area where a program is (or will be) stored.
PAGE is automatically initialised by BBCBASIC(Z80) to the address of the lowest available page in RAM, but you may change it.
PAGE is always located on a page boundary (every 256 bytes).
If you make PAGE less than its original value or greater than the original value of HIMEM, you will get a "Bad program" error when you try to enter a program line and you may well crash BBCBASIC(Z80).
If you make PAGE greater than HIMEM, a "No room" error will occur if the program exits to command level.
USE WITH CARE.
PI
A function returning 3.14159265.
You can use PI to calculate the circumference and area of a circle.
The example below calculates the circumference and area of a circle of a given radius.
PI can also be used to convert degrees to radians and radians to degrees.
However, BBCBASIC(Z80) has 2 functions (RAD and DEG) which perform these conversions to a higher accuracy.
PLOT PL.
Not available on the Z88
POINT
Not available on the Z88
POS
A function returning the horizontal position of the cursor on the screen.
The left hand column is 0 and the right hand column is one less than the width of the display.
COUNT will tell you the print head position of the printer.
It is an uncertain indicator of the horizontal position of the cursor on the screen.
(See the keyword COUNT for details.)
See VPOS for an example of the use of POS and VPOS.
PRINT P.
A statement which prints characters on the screen.
You can also echo the characters to the printer.
Printer echo is controlled with the following key sequences.
The items following PRINT are called the print list.
The print list may contain a sequence of string or numeric literals or variables.
The spacing between the items printed will vary depending on the punctuation used.
If the print list does not end with a semi-colon, a new-line will be printed after all the items in the print list.
General Information
In the examples which follow, commas have been printed instead of spaces to help you count.
The screen is divided into zones (initially) 10 characters wide.
By default, numeric quantities are printed right justified in the print zone and strings are printed just as they are (with no leading spaces).
Numeric quantities can be printed left justified by preceding them with a semi-colon.
In the examples the zone width is indicated as z10, z4etc.
Initially numeric items are printed in decimal.
If a tilde () is encountered in the print list, he numeric items which follow it are printed in hexadecimal.
If a comma or a semi-colon is encountered further down the print list, the format reverts to decimal.
A comma (,) causes the cursor to TAB to the beginning of the next print zone unless the cursor is already at the start of a print zone.
A semi-colon causes the next and following items to be printed on the same line immediately after the previous item.
This "no-gap" printing continues until a comma (or the end of the print list) is encountered.
An apostrophe (') will force a new line.
TAB(X) and TAB (Y, Z) can also be used at any position in the print line to position the cursor.
Unlike most other versions of BASIC, a comma at the end of the print list will not suppress the new line and advance the cursor to the next zone.
If you wish to split a line over 2 or more PRINT statements, end the previous print list with a semicolon and start the following list with a comma or end the line with a comma followed by a semicolon.
Printing a string followed by a numeric effectively moves the start of the print zones towards the right by the length of the string.
This displacement continues until a comma is encountered.
Although PRINT USING is not implemented in BBCBASIC, similar control over the print format can be obtained.
The overall width of the print zones and print field, the number of figures or decimal places and the print format may be controlled by setting the print variable, @%, to the appropriate value.
The print variable (@%) comprises 4 bytes and each byte controls one aspect of the print format.
@% can be set equal to a decimal integer, but it is easier to use hexadecimal, since each byte can then be considered separately.
Print Format Control
SS effects the format of the string generated by the STR$ function.
If SS is 01 the string will be generated according to he format set by @%, otherwise @% will be ignored and the G9 format used.
STR$ Format Control — SS
NN selects the general format as follows: G Format Numbers that are integers are printed as such.
Numbers in the range 0.1 to 1 will be printed as such.
Numbers less than 0.1 will be printed in E format.
Numbers greater than the range set by Byte 1 will be printed in E format.
In which case, the number of digits printed will still be controlled by Byte 1, but according to the E format rules.
Format Selection — NN
The earlier examples were all printed in G9 format.
E Format Numbers are printed in the scientific (engineering) notation.
F Format Numbers are printed with a fixed number of decimal places.
PP controls the number of digits printed in the selected format.
The number is rounded (NOT truncated) to this size before it is printed.
If PP is set outside the range allowed for by the selected format, it is taken as 9.
The effect of PP differs slightly with the various formats.
Number of Digits — PP
G 1-0A The maximum number of digits which can be printed, excluding the decimal point, before changing to the E format.
Format Range Control Function
E 1-FF The total number of digits to be printed excluding the decimal point and the digits after the E. Three characters or spaces are always printed after the E. If the number of significant figures called for is greater than 10, then trailing zeros will be printed.
Format Range Control Function
F 0-0A The number of digits to be printed after the decimal point.
WW sets the width of the print zones and field.
followed by It is possible to change the print control variable (@%) within a print list by using the function: Functions have to return an answer, but the value returned by this function is a null string.
Consequently, its only effect is to change the print control variable.
Thus the PRINT statement will print x in G9z10 format and y in F2z10 format.
Zone Width — WW
Changing the Print Control Variable
The results obtained by running the following example program show the effect of changing the zone width.
The results for zone widths of 5 and 10 (& oa ) illustrate what happens when the zone width is too small for the number to be printed properly.
The example also illustrates what happens when the number is too large for the chosen precision.
Examples
PRINT# P.#
A statement which writes the internal form of a value out to a file (or device).
The format of the variables written to the file differs from the format used on the BBC Micro.
All numeric values are written as five bytes of binary real data (see the Annex entitled "Format of Program and Variables in Memory" ).
Strings are written as the bytes in the string (in the correct order) plus a carriage return.
Before you use this statement, you must have opened a file using OPENOUT or OPENUP.
You can use PRINT# to write data (numbers and strings) to a data file in the "standard" manner.
If you wish to "pack" your data in a different way, you should use BPUT#.
You can use PRINT# an BPUT"together to mix or modify the data format.
For example, if you wish to write a "compatible" text file, you could PRINT# the string and BPUT# a line-feed.
This would write the string followed by a carriage-return and a line-feed to the file.
Remember, with BBCBASIC(Z80) the format of the file is completely under your control.
PROC
A keyword used at the start of all user declared procedures.
The first character of a procedure name can be an underline (or a number).
If there are spaces between the procedure name and the opening bracket of the parameter list (if any) they must be present both in the definition and the call.
It's safer not to have spaces between the procedure name and the opening bracket.
A procedure may be defined with any number of parameters of any type.
A procedure definition is terminated by ENDPROC.
A procedure does not have to be declared before it is called.
Procedures are reentrant and the parameters (arguments) are passed by value.
See the "Procedures and Functions" sub-section for more details.
PTR#
A pseudo-variable allowing the random-access pointer of the file whose file handle is its argument to be read and changed.
Reading or writing (using BGET#, BPUT#, INPUT# or PRINT#) takes place at the current position of the pointer.
The pointer is automatically updated following a read or write operation.
You can use PTR# to select which item in a file is to be read or written to next.
In a random file (see the section on BBCBASIC(Z80) Files) you can use PTR# to select the record you wish to read or write.
If you wish to move about in a file using PTR# you will need to know the precise format of the data in the file.
A file opened with OPENUP may be extended by setting its pointer to its end (PTR#fnum=EXT#fnum) and then writing to it.
If you do this, you must remember to CLOSE the file when you have finished with it in order to update the directory entry.
By using PTR# you have complete control over where you read and write data in a file.
This is simple concept, but it may initially be difficult to grasp its many ramifications.
The "BBCBASIC(Z80) Files" section has a number of examples of he use of PTR#.
PTR#-Returns the number of file handles still available for the entire Z88 (not just BBCBASIC(Z80)) and the ROM release number.
If you are going to display this information, you will need to do so in hexadecimal because the one (4 byte) number contains 2 items of information For example, The last 3 digits (least significant 2 bytes) are the ROM release number.
The first 2 digits (most significant 2 bytes) are the number of files handles still available for use by the filing system (& 5a =90).
PUT
A statement to output data to an output port.
Full 16-bit addressing is available.
This instruction gives direct access from BBCBASIC(Z80) to the computer's I/O hardware.
Typically, you can use it to directly access I/O ports.
It is strongly recommended that you do not try to control the Z88's hardware with this command — a mistake can be disastrous.
However, if you insist on directly access the Z88's hardware, you will need a copy of the Z88 Developers' Notes (available from Cambridge Computer Ltd).
This is an addition to the original language specification and it cannot be guaranteed to remain unchanged in future releases.
RAD
A function which converts degrees to radian.
Unlike humans, BBCBASIC(Z80) wants angles expressed in radians.
You can use this function to convert an angle expressed in degrees to radians before using one of the angle functions (SIN, COS, etc).
Using RAD is equivalent to multiplying the degree value by PI/180, but the result is calculated internally to a greater accuracy.
See COS, SIN and TAN for further examples of the use of RAD.
READ
A statement which will assign to variables values read from the DATA statements in the program.
Strings must be enclosed in double quotes if they have leading spaces or contain commas.
In many of your programs, you will want to use data values which do not change frequently.
Because these values are subject to some degree of change, you won't want to use constants.
On the other hand, you won't want to input them every time you run the program either.
You can get the best of both worlds by declaring these values in DATA statements at the beginning or end of your program and READing them into variables in your program.
A typical use for DATA and REAd is a name and address list.
The addresses won't change very often, but when they do you can easily amend the appropriate DATA statement.
See DATA for more details and an example of the use of DATA and READ.
REM
A statement that causes the rest of the line to be ignored thereby allowing comments to be included in a program.
You can use the REM statement to put remarks and comments in to your program to help you remember what the various bits of your program do.
BBCBASIC(Z80) completely ignores anything on the line following a REM statement.
You will be able to get away without including any REMarks in simple programs.
However, if you go back to a lengthy program after a couple of months you will find it very difficult to understand if you have not included any REMs.
If you include nothing else, include the name of the program, the date you last revised it and a revision number at the start of your program.
RENUMBER
A command which will renumber the lines and correct the cross references inside a program.
The options are as for AUTO, but increments of greater than 255 are allowed.
You can specify both the new first number (n1) and/or step size (s).
The default for both the first number and the step size is 10.
The 2 parameters should be separated by a comma or a hyphen.
For example: RENUMBER produces error messages when a cross reference fails.
The line number containing the failed cross-reference is renumbered and the line number in the error report is the new line number.
If you renumber a line containing an ON GOTO/GOSUB statement which has a calculated line number, RENUMBER will correctly cope with line numbers before the calculated line number.
However, line numbers after the calculated line number will not be changed.
In the following example, the first 2 line numbers would be renumbered correctly, but the last 2 would be left unchanged.
RENUMBER may be used in a program, but it will exit to the command mode on completion.
REPEAT REP.
A statement which is the starting point of a REPEAT…
UNTIL loop.
A single REPEAT may have more than one UNTIL, but this is bad practice.
The purpose of a REPEAT…
UNTIL loop is to make BBCBASIC(Z80) repeat a set number of instructions until some condition is satisfied.
You must not exit a REPEAT…
UNTIL loop with a GOTO.
If you jump out of a loop with a GOTO (How could you!!!) you should jump back in.
If you must jump out of the loop, you should use UNTIL TRUE to "pop" the stack.
For (a ghastly) example: See the keyword UNTIL for ways of using REPEAT…
UNTIL loops to replace unconditional GOTOs for program looping.
See the sub-section on "Program Flow Control" in the "General Information" section for more details on the working of the program stack.
REPORT REPO.
A statement which prints out the error string associated with the last error which occurred.
You can use this statement within your own error handling routines to print out an error message for those errors you are not able to cope with.
The example below is an error handling routine designed to cope only with the <ESCAPE> key being pressed.
All other errors are reported and the program terminated.
See the sub-section on Error Handling and the keywords ERR, ERL and ON ERROR for more details.
RESTORE RES.
RESTORE can be used at any time in a program to set the line where DATA is read from.
RESTORE on its own resets the data pointer to the first data item in the program.
RESTORE followed by a parameter sets the data pointer to the first item of data in the specified line (or the next line containing a DATA statement if the specified line does not contain data).
This optional parameter for RESTORE can specify a calculated line number.
You can use RESTORE to reset the data pointer to the start of your data in order to reuse it.
alternatively, you can have several DATA lists in your program and use RESTORE to set the data pointer to the appropriate list.
RETURN R.
A statement causing a RETURN to the statement after the most recent GOSUB statement.
You use RETURN at the end of a subroutine to make BBCBASIC(Z80) return to the place in your program which originally "called" the subroutine.
You may have more than one return statement in a subroutine, but it is preferable to have only one entry point and one exit point (RETURN).
Try to structure your program so you don't leave a subroutine with a GOTO.
If you do, you should always return to the subroutine and exit via the RETURN statement.
If you insist on using GOTO all over the place, you will end up confusing yourself and maybe confusing BBCBASIC(Z80) as well.
The sub-section on Program Flow Control explains why.
RIGHT$
A string function which returns the right "num" characters of the string.
If there are insufficient characters in the string then all are returned.
There must not be any spaces between the RIGHT$ and the opening bracket.
RND
A function which returns a random number.
The type and range of the number returned depends upon the optional parameter.
If n is negative the pseudo random sequence generator is set to a number based on n and n is returned.
If n is 0 the last random number returned in RND(1) format.
The random number generator is initialised by RUN (or CHAIN).
Consequently, RND will return zero until the RUN (or CHAIN) command is first issued.
RUN
Start executing of the program.
RUN is a statement and so programs can re-execute themselves.
All variables except A% to Z% and @% are CLEARed by RUN.
If you want to start a program without clearing all the variables, you can use the statement where nnnn is number of the line at which you wish execution of the program to start.
RUN can be used as an alternative to CHAIN.
SAVE SA.
A statement which saves the current program area to a file (or device), in internal (tokenised) format.
You use SAVE to save your program for use at a later time.
The program must be given a name (file or device specifier) an this name becomes the name of the file in which your program is saved.
The name (file or device specifier) must follow the normal Z88 file/device naming conventions.
See the "Operating System Interface" section for a description of a file/device specifier (name).
SGN
A function returning -1 for negative argument, 0 for zero argument an +1 for positive argument.
You can use this function to determine whether a number is positive, negative or zero.
SGN returns:
SIN
A function giving the sine of its radian argument.
This function returns the sine of an angle.
The angle must be expressed in radians, not degrees.
Whilst the computer is quite happy dealing with angles expressed in radians, you may prefer to express angles in degrees.
You can use the RAD function to convert an angle from degrees to radians.
The example below sets Y to the sine of the angle "degree_angle" expressed in degrees.
SOUND
No available on the Z88.
SPC
A statement which prints a number of spaces to the screen (or currently selected console output stream).
The argument specifies the number of spaces (up to 255) to be printed.
SPC can only be used within a PRINT or INPUT statement.
SQR
A function returning the square root of its argument.
If you attempt to calculate the square root of a negative number, a "-ve root" error will occur.
You could use error trapping to recover from this error, but it is better to check that the argument is not negative before using the SQR function.
STEP S.
Part of the FOR statement, this optional section specifies step sizes other than 1.
The step may be positive or negative.
STEP is optional; if it is omitted, a step size of +1 is assumed.
You can use this optional part of the FOR…
TO…
STEP…
NEXT structure to specify the amount by which the FOR…
NEXT loop control variable is changed each time round the loop.
In the example below, the loop control variable, "cost" starts as 20, ends at 5 and is changed by -5 each time round the loop.
STOP
Syntactically identical to END, STOP also prints a message to the effect that the program has stopped.
You can use STOP at various places in your program to aid debugging.
If your program is going wrong, you can place STOP commands at various points to see the path taken by your program.
(TRACE is generally a more useful aid to tracing a program's flow unless you are using formatted screen displays.)
Once your program has STOPped you can investigate the values of the variables to find out why things happened the way they did.
STOP DOES NOT CLOSE DATA FILES.
If you use STOP to exit a program for debugging, CLOSE all the data files before RUNning the program again.
If you don't you will get some most peculiar error messages.
STR$
A string function which returns the string form of the numeric argument as it would have been printed.
If the most significant byte of @% is not zero, STR$ uses the current @% description when generating the string.
If it is zero (the initial value) then the G9 format (see PRINT) is used.
If STR$ is followed by (tilde) then a hexadecimal conversion is carried out.
The opposite function to STR$ is performed by the VAL function.
STRINGS$
A function returning N concatenations of a string.
You can use this function to print repeated copies of a string.
It is useful for printing headings or underlinings.
The last example for PRINT uses the STRING$ function to print the column numbers across the page.
For example,
TAB
A statement available in PRINT or INPUT.
There are 2 versions of TAB, TAB(X) and TAB (X, Y) and they are effectively 2 different statements.
TAB(X) is a printer orientated statement.
The number of printable characters since the last new-line (COUNT) is compared with X. If X is equal or greater than COUNT, sufficient spaces to make them equal are printed.
These spaces will overwrite any characters which may already be on the screen.
If X is less than COUNT, a new-line will be printed first.
TAB (X, Y) is a VDU orientated statement.
It will move the cursor on the VDU screen to character cell X, Y (column X, row Y) if possible.
No characters are overwritten and COUNT is NOT updated.
Consequently, a TAB (X, Y) followed by a TAB(X) will give unpredictable (at first glance) results.
The leftmost column is column 0 an the top of the screen is row 0.
TAN T.
A function giving the tangent of its radian argument.
This function returns the tangent of an angle.
The angle must be expressed in radians, not degrees.
Whilst the computer is quite happy dealing with angles expressed in radians, you may prefer to express angles in degrees.
You can use the RAD function to convert an angle from degrees to radians.
The example below sets Y to the tangent of the angle "degree_angle" expressed in degrees.
THEN TH.
An optional part of the IF…
THEN…
ELSE statement.
It introduces the action to be taken if the testable condition evaluates to TRUE.
You need to use THEN if it is followed by: or you wish to exit from a function as a result of the test.
This is because BBCBASIC(Z80) can't work out what you mean in these circumstances if you leave the THEN out.
TIME TI.
A pseudo-variable which reads and sets the elapsed time clock.
You can use TIME to set and read BBCBASIC(Z80)'s internal clock.
The value of the clock is returned in centi-seconds (one-hundredths of a second) and it is quite accurate.
A delay loop such as is quite likely to fail.
The compound condition test should always be used.
On starting BBCBASIC(Z80), TIME may be found to be "stuck" at a large value.
To cure this, it should be initialised (TIME=0, for example).
The following example is a single program to provide a 24 hour clock.
Lines 20 to 40 to get the correct time, lines 50 and 60 calculate the number of centi-seconds and set TIME, and lines 110 to 130 convert the value in TIME to hours, minutes and seconds.
Line 90 stops the time being printed unless it has changed by at least one second.
TIMES$
A 24 character long string pseudo-variable which reads and sets the system clock.
The format of the character string is: Where: The date or both date and time may be set as show below.
When setting the clock, the day of the week may be omitted.
The Z88 is remarkable in that it will accept almost any date format.
The following examples demonstrate this to some extent.
Neither of them conforms to the default format, but they both work.
The first example below sets only the date and the second sets the date and the time.
In general, you will find it easier to use T to set the date and time.
If the Z88 cannot make sense of the string or the day/date is impossible, a "Bad syntax" error will be reported.
TO
The part of the FOR…
TO…
STEP statement which introduces the terminating value for the loop.
When the loop control variable exceeds the value following "TO" the loop is terminated.
For example, Irrespective of the initial value of the loop control variable and the specified terminating value, the loop will execute at least once.
For example,
TOP
A function which returns the value of the first free location after the end of the current program.
The length of your program is given by TOP-PAGE.
TRACE TR.
TRACE ON causes the interpreter to print executed line numbers when it encounters them.
TRACE X sets a limit on the size of line numbers which will be printed out.
Only those line numbers less than X will appear.
If you are careful and place all your subroutines at the end of the main program, you can display the main structure of the program without cluttering up the trace with the subroutines.
TRACE OFF turns trace off.
TRACE is also turned off if an error is reported or you press <Esc>.
Line numbers are printed as the line is entered.
For example, would trace as and would trace as
TRUE
A function returning the value -1.
BBCBASIC(Z80) does not have true Boolean variables.
Instead, numeric variables are used and their value is interpreted in a "logical" manner.
A value of 0 is interpreted as false and NOT FALSE (in other words, NOT 0 (= -1)) is interpreted as TRUE.
In practice, any value other than zero is considered TRUE.
This can lead to confusion; see the keyword NOT for details.
See the Variables sub-section for more details on Boolean variables and the keyword AND for logical tests and their results.
UNTIL U.
The part of the REPEAT…
UNTIL structure which signifies its end.
You can use a REPEAT…
UNTIL loop to repeat a set of program instructions until some condition is met.
If the condition associated with the UNTIL statement is never met, the loop will execute for ever.
(At least, until <Esc> is pressed or some other error occurs.)
The following example will continually ask for a number and print its square.
The only way to stop it is by pressing <Esc> or forcing a "Too big" error.
Since the result of the test z=o is ALWAYS FALSE, we can replace z=0 with FALSE.
The program now becomes: This is a much neater way of unconditionally looping than using a GOTO statement.
The program executes at least as fast and the section of program within the loop is highlighted by the indentation.
See the keyword REPEAT for more details on REPEAT…
UNTIL loops.
See the Variables sub-section for more details on Boolean variables and the keyword AND for logical tests and their results.
USR
A function which allows a machine code routine to return a value directly.
USR calls the machine code subroutine whose start address is its argument.
Prior to calling the subroutine, The processor's A, B, C, D, E, F, H and L registers are initialised to the least significant words of A%, B%, C%, D%, E%, F%, H% and L% respectively (see also CALL).
USR provides you with a way of calling a machine code routine which is designed to return one integer value.
Parameters are passed via the processor's registers and the machine code routine returns a 32-bit integer result composed of the processor's HL and H'L"registers.
The HL register forms the most significant word of the result.
Unlike CALL, USR returns a result.
Consequently, you must assign the result to a variable.
It may help your understanding if you look upon CALL as the machine code equivalent to a PROCedure and USR as the equivalent to Function.
VAL
A function which converts a character string representing a number into numeric form.
VAL makes the best sense it can of its argument.
If the argument starts with numeric characters (with or without a preceding sign), VAL will work from left to right until it meets a non numeric character.
It will then "give up" and return what it has got so far.
If it can't make any sense of its argument, it returns zero.
For example, would print VAL will NOT work with hexadecimal numbers.
You must use EVAL to convert hexadecimal number strings.
VDU V.
A statement which takes a list of numeric arguments and sends their least-significant bytes as characters to the display.
A 16-bit value can be sent if the value is followed by a ";" .
It is sent as a pair of characters, least significant byte first.
The bytes sent using the VDU statement do not contribute to the value of COUNT, but may well change POS and VPOS.
You can use VDU to send characters direct to the screen without having to use a PRINT statement.
It offers a convenient way of sending a number of control characters to the screen.
It also differs from PRINT CHR$ (n) in that you cannot use it to send codes or characters to the printer.
VPOS VP.
A function returning the vertical cursor position.
The top of the screen is line 0.
You can use VPOS in conjunction with POS to return to the present position on the screen after printing a message somewhere else.
The example below is a procedure for printing a "status" message at line 23.
The cursor is returned to its previous position after the message has been printed.
WIDTH W.
A statement controlling output overall field width.
If the specified width is zero (the initial value) the interpreter will not attempt to control the overall field width.
WIDTH n will cause the interpreter to force a new line after n MOD 256 characters have been printed.
WIDTH also affects the output to the printer.
The Screen Driver
Introduction 5.1
As with the BBC Micro, the VDU command may be used to send characters to the Z88 Screen Driver.
Since the Z88 is very different to the BBC Micro, there are considerable differences in the action of the VDU commands.
In many ways the VDU command is similar to a PRINT CHR$ (num) command, but it involves less typing and a number of characters may be easily sent.
It is most often used for sending characters that control the action of the Screen Driver.
The VDU statement takes a list of numeric arguments (constants or variables) and sends their least significant bytes as characters to the screen.
A 16 bit value (word) can be sent if the value is followed by a semi-colon.
It is sent as a pair of characters, the least significant byte first.
You cannot use the VDU command to send control sequences to a device (: PRT.0, for example).
This section lists and briefly describes the control codes and their function.
VDU Code Summary 5.2
Escape Sequences 5.2.1
The character ASCII code 1 is used to introduce special character combinations called "Escape Sequences" which print special characters on the screen, toggle the current printing mode, position the cursor on the screen define windows and perform various display control functions.
Description of VDU Codes 5.3
VDU 0 5.3.1
Does nothing.
In other words, it is ignored.
This is the "Escape" code which introduces numerous screen printing and control sequences which are described in the "Description of Escape Sequences" sub-section.
VDU 1 5.3.2
VDU 7 causes a short "beep" from the speaker.
VDU 8 moves the cursor one character to the left.
If the cursor was at the start of a line, it moves to the end of the previous line (right edge of the text window).
If it was also at the top line of the text window and scroll is enabled, the window scrolls down.
VDU 7 5.3.3
VDU 8 5.3.4
If a window has been defined, the cursor is constrained to remain within the window.
VDU 9 moves the cursor one character to the right.
If the cursor was at the end of a line, it moves to the start of the next line (left edge of the window).
If the cursor was also at the bottom of a window and scroll is enabled, the window scrolls up.
VDU 9 5.3.5
If a window has been defined, the cursor is constrained to remain within the window.
VDU 10 moves the cursor down one line.
If the cursor was on the bottom line of the window and scroll is enabled, the window scrolls up.
VDU 10 5.3.6
If a window has been defined, the cursor is constrained to remain within the window.
VDU 11 moves the cursor up one line.
If the cursor was on the top line of the window and scroll is enabled, the window scrolls down.
VDU 11 5.3.7
If a window has been defined, the cursor is constrained to remain within the window.
VDU12 clears the text window and moves the cursor to the top left corner of the window; it is identical to CLS.
VDU 12 5.3.8
VDU 13 moves the cursor to the left edge of the window, but does not move it vertically.
VDU 13 5.3.9
If a widow has been defined, the cursor is constrained to remain within the window.
Prints a black square.
VDU 127 5.3.10
Description of Escape Sequences 5.4
Introduction 5.4.1
The character ASCII code 1 is used as an "Escape" character to introduce special code sequences that: The escape character is followed by A single special character.
or A sequence of codes, the first of which specifies the number of parameters (bytes) to follow.
The parameter count may take one of two forms.
It may be the ASCII code for a single decimal digit (49 to 57).
or It may be a binary number with bit-7 set (128 added to the number).
Most escape sequences have less than 10 following parameters, and the first method of specifying the parameter count is generally used.
Numbers not characters are used as parameters in the VDU command, so the ASCII character "2" , for example, would appear as 50 (its ASCII value), or as ASC "2" .
Where appropriate, the escape sequences are shown in 2 ways (both of which send identical code sequences to the screen driver).
The first is the easiest to remember since it uses characters that are related to the name of the function the sequences is performing (as mnemonic).
However, this method uses the "ASC" function to convert the characters into their ASCII codes.
The second method uses the actual codes sent to the screen driver.
Whilst this is more difficult to remember, it involves less typing.
It is possible to position the cursor within the current window (see later) with an Escape Sequence.
Special Characters 5.4.2
Positioning the Cursor
The following Escape sequences toggle various display attributes.
The new attributes apply to characters subsequently printed to the screen.
Display Attributes
To avoid having to remember the current state of the display, the attributes may be set explicitly by prefixing the control byte by a parameter count of 50 (the character "2" ) and 43 ( "+" ) for "on" a 45 ( "-" ) for "off" .
For example, will cause all subsequent characters to be printed to the screen in inverse video until the command or returns printing to normal.
You can combine a number of attribute characters in a single VDU command.
For example, will cause subsequently printed characters to be printed to the screen in flashing inverse video.
All the attributes can be set back to the system default (off) with the command; It is possible to change the "hardware" attributes (flash, grey, reverse and underline) of text already printed on the screen.
Cancelling Display Attributes 5.4.4.1
Changing Display Attributes 5.4.4.2
The "current toggles" are the current toggle settings, not the attributes of the character under the cursor.
For example, the following code sequence would invert the first 20 characters on line 0 starting a column 0.
The last 2 lines could be combined as
Test Justification and Margins 5.4.5
You can control how the text is positioned within a window with the following justification Escape sequences.
Up to 6 display windows may be defined by the user on the Z88; they are referred to by a single ASCII character "1" to "6" .
Windows "7" and "8" are used by the Z88 operating system.
Window "7" is the "Topic" area and window "8" is used by a number of system calls for error processing.
Windows 5.4.6
Windows "remember" their attribute settings (see earlier), but if a window area is overwritten then the window's contents are lost.
The "OZ" window contains special characters which control the scanning of the screen and if these are disturbed, the display will not work properly.
Consequently, it is very important that windows do not go beyond the width of the screen and overwrite the "OZ" window.
To avoid this, windows should not be more than 94 6-pixel characters from the edge of the applications window (104 6-pixel characters from the leftmost edge of the screen).
The following Escape Sequence command defines a window.
Defining a Window 5.4.6.1
Where "n" is the ASCII code for the window (49 to 54).
The "x" and "y" parameters are usually relative to the top left-hand-corner of the applications area.
They may be made absolute (relative to the top left-hand corner of the screen) by using 128+x and 128+y in the Escape sequence.
The "type" parameter is optional.
If the parameter count is set to 54 (ASC "6" ) it may be omitted and a window without bars or brackets will be defined.
Once defined, output may be directed to window "n" ( "1" to "6" — ASCII 49 to 54) with the following Escape sequences: The Z88 system uses windows extensively.
The filer, for example, uses a window with "shelf brackets" and tiny/inverted/underlined text to produce a banner heading for the window.
The following BBCBASIC(Z80) program demonstrates a "bannered" window.
Selecting a Window 5.4.6.2
User Defined Characters 5.4.7
You can define characters based on a 6x8 matrix with the following Escape sequence: The character code, char_code, must be between 64 ( "@" ) and 127 ().
The parameters "r0" to "r7" are the numeric values of the top to bottom rows of the character with bit-7 set.
Their values must, therefore, lie between 128 (bit-7 set to 1) and 191 (bit-7 and bits 1 to 5 set to 1).
Bit-5 is the left-hand column (bit-5) blank.
If user-defined characters are to be mixed with standard characters, they should follow this convention.
Notice that the parameter count is 10 and it is consequently specified in the "alternative" way.
If a lesser number of parameters are specified, the unspecified rows will be set to 0.
This is useful, since many characters have a blank bottom row.
User defined characters co-exist with standard characters, the do not overwrite them as on the BBC Micro.
User defined characters may be printed using the following Escape sequence: On an unexpanded Z88 (one without 128k or more in slot 1), only 16 characters may be defined without encroaching on the PipeDream map.
Characters above the limit of 16 may be overwritten by map information when PipeDream is run.
If the PipeDream map width is less than 65 pixels, then all the User Defined Characters may be used.
Printing User Defined Characters 5.4.7.1
Limitations 5.4.7.2
The following Escape sequences control window scrolling.
Miscellaneous Functions 5.4.8
Window Scrolling 5.4.8.1
The following Escape sequences control window greying.
Grey Window 5.4.8.2
The following Escape sequences sends the same code a number of times.
Multiple Output 5.4.8.3
The following Escape sequences rings the "bell" a number of times.
Multiple Bell
For example, the following VDU command will sound 3 "beeps" of 2 seconds each with 1/2 a second between each "beep" 
Operating System Interface
Introduction 6.1
As with the BBC Micro computer the (*) commands provide access to the operating system.
Since the BBC operating system is very different to the Z88's, there are considerable differences in the star commands.
When a star command is issued, BBCBASIC(Z80) passes it to the Z88's operating system for action.
If it is not recognised, a "Bad command" error is reported.
File and device specifiers must comply with the standard Z88 filer conventions.
These conventions are described at Appendix D to the Z88 manual and summarised briefly below.
File Specifiers 6.1.1
The final .0 of a device name may be omitted if the device is unique.
For example,: COM.O may be abbreviated to: COM
There is a bug in versions of the filer up to and including version 3 that will cause the Z88 to crash if you use the device: RAM.
-and then perform a soft reset whilst any files are still present in the device.
You can avoid this problem by deleting any files in: RAM.
-as soon as you have finished with them.
The list of directories which must be followed in order to find the specified file.
The names of each directory in the path must be separated by the slash (divide) character.
If the path is omitted, the current directory on the specified drive is assumed.
path
The name of the file.
The length of the name must not exceed 12 characters.
filename
The optional extension of the file.
If an extension is used it must be separated from the filename by a full-stop.
extension
The standard Z88 "wild-cards" may be used when an ambiguous file specifier is acceptable.
The following symbols and abbreviations are used as part of the explanation of the operating system commands.
Symbols
Accessing Star Commands 6.2
The star commands may be accessed directly or via the OSCLI statement.
The 2 examples below both delete the file "WOMBAT" .
A star command must be the last (or only) command on a program line and its argument may not be a variable.
If you need to use one of these commands with a variable as the argument, use the OSCLI statement.
Examples of the use of the OSCLI statement are given later.
Syntax 6.2.1
Star commands and their associated qualifiers are converted from lower-case to upper-case if necessary.
For example, *DELETE wombat is converted to *DELETE WOMBAT.
This is in keeping with the general Z88 philosophy and the BBC Micro's machine operating system (MOS).
Case Conversion 6.2.2
Star Commands 6.3
Pass the following string to the Command Line Interpreter (CLI) for action.
The use of the CLI is explained later in this section.
See the "Command Line Interpreter" sub-section for more details.
Delete the specified file.
*DELETE 6.3.2
This command will delete only one file at a time; wild-cards are not permitted in the file specifier.
If you wish to delete more than one file, you should use the "Erase" function of the "Filer" .
This command is synonymous with *DELETE.
*ERASE 6.3.3
Assign a "name" to the current instantiation of BBCBASIC(Z80).
*NAME 6.3.4
The list of suspended activities shown when the Z88's index is selected has space for "Your Reference" for each of the suspended activities.
This reference may be up to 15 characters long.
The *NAME command allows you to specify the reference for the current instantiation of BBCBASIC(Z80).
If the reference exceeds 15 characters, it is truncated.
For example would appear in the list of suspended activities as: *SPOOL and *EXEC are not available on the Z88.
However, you can perform similar functions using the CLI as shown below.
(The "+" represents the "=/+" key — you don't have to use the <SHIFT> key.)
*SPOOL and *EXEC 6.3.5
Use PipeDream to add".
J"as the first line.
Remember to load and save the file in plain text mode.
You can now use the command to "*EXEC" the file back into BBCBASIC(Z80) You can use this technique to produce a text file for extensive editing in PipeDream.
Rename a file.
OSCLI can also be used to rename a file.
Using OSCLI has the advantage that the file names may be string variables.
*RENAME 6.3.6
The Command Line Interpreter (CLI) 6.4
The Z88 Command Line Interpreter (CLI) is very powerful.
It "sits" between the keyboard and the current application and interprets the keys that you press.
In most cases, the characters for the keys that you press are passed directly to the application that is currently active.
However, some keys, <INDEX> and for example, have a particular significance to the CLI and they cause subsequent key presses to be interpreted as CLI commands and actioned accordingly.
For example, pressing the key followed by the F key will take you into the filer popdown.
You can use the CLI to make changes to the way the Z88 behaves.
Any such changes are confined to the application that was active at the time.
The CLI takes its input from the keyboard or from a file.
Thus, the CLI acts in many ways like a programming language for controlling the way the computer functions.
The CLI may receive commands from a file as well as from the keyboard (or the current input stream).
For example, from within the FILER popdown, the following key sequence will invoke (run) the CLI command file "prnt.cli" .
CLI Command Files 6.4.1
A CLI command file is terminated when the end of the file is reached or it is suspended (see later).
Control is then returned to the CLI.
You can use the command within one CLI command file to invoke another CLI command file.
When the second CLI command file terminates, control is returned to the first CLI command file.
The only way to cancel a CLI command file whilst it is running or suspended is by pressing the <SHIFT> and <ESC> keys together.
Since this sequence cannot be represented in any other way (see below), you cannot cancel a suspended CLI command file from within a program.
Cancelling a CLI File 6.4.1.1
You can cancel all CLI command files by pressing (fig><ESC>.
Some of the keys on the keyboard, and for example, have no ASCII code.
However, some way of representing these keys is required when input is taken from a CLI command file (or redirected).
The ASCII character sequences listed below represent many of the "non-printable" keys.
Unfortunately not all key sequences may be represented in this manner.
For instance, there is no way of representing <CAPS LOCK> key or <ESC>.
Special Character Sequences 6.4.1.2
File Control Commands 6.4.2
A full stop at the beginning of a line in a CLI command file introduces the I/0 redirection and additional file control commands as described below.
The standard input and output for the Z88 initially come from and go to the keyboard and the screen.
In computer jargon, they are "bound" to the keyboard and the screen.
I/0 Redirection 6.4.2.1
You can change the input and output binding (redirect the I/0) with the following CLI commands: Don't forget that as far as the Z88 is concerned there is no difference between a "real" file and a device.
For example, the device: COM.0 is treated in the same way as a file by the Z88.
In addition to completely redirecting the input or output, you can also copy the input or output stream to a file with the following CLI commands: The previous output redirection commands apply to the standard output.
If you want to redirect the Printer output, you may so do with the following CLI commands: The following additional commands are only effective from within a CLI file or from redirected input.
Additional CLI File Commands 6.4.2.2
Any re-bindings are in effect only for the duration of the CLI command file.
You may suspend a CLI command file and maintain the bindings with the".
S"command.
However, once you have done so, the only way of cancelling the CLI is by pressing <SHIFT >/; <ESCAPE> on the keyboard.
Re-binding Within a CLI Command File 6.4.3
Accessing The CLI From BBCBASIC(Z80) 6.5
You can access the CLI from within BBCBASIC(Z80) by using the *CLI or OSCLI commands.
The following examples perform identically and cause a 10 second delay.
You can invoke a CLI file from within BBCBASIC(Z80) using either the *CLI or OSCLI commands.
For example will invoke the CLI command file "filename" .
The advantage of using the OSCLI command is that you can use a variable for the file name and the command does not need to be the last (or only) one on a line.
For example, the following command will invoke the CLI command file whose name is held in the variable "fname$" .
A command passed to the CLI is not executed until the CLI gains control, and this only happens when input is expected from the keyboard (or redirected input file).
This is no problem if you are in BBCBASIC(Z80)'s immediate mode where the computer is waiting for you to type something.
However, if you are in a program, the commands queued to the CLI will not be actioned until the program pauses for input, or ends and exits to immediate mode.
You can force the CLI to look for input by appending an INKEY(0) command to the end of your OSCLI command line.
For example, the following command will invoke the CLI command file "prntr.cli" and execute it, instigating the redirection which it sets up.
The file "prntr.cli" may be created using PipeDream and saved as a plain text file with the name "prntr.cli" .
The file contains the following commands, for example.
The use of this file is explained more fully in the "Printing" section of the manual.
Don't forget that the only way to remove a suspended CLI is by pressing <SHIFT >/; <ESC> on the keyboard.
You cannot issue a command from within a program that will remove it.
For this reason, you should avoid the use of suspended CLI files wherever possible.
CLI Command Examples 6.5.1
Example 1 6.5.1.1
From within BBCBASIC(Z80), the following command line will enter the Panel popdown, turn sound off and return to BASIC.
The line may be included in a BBC BASIC program or entered in the direct mode.
As previously mentioned, CLI commands are not executed until control is passed to the CLI.
You can demonstrate this with a short program incorporating the previous example.
When you RUN the following program, you will note that "LINE 10" and "LINE 30" are printed before the Panel popdown is entered.
Example 2 6.5.1.2
Changing line 20 to forces the execution of the CLI command before "LINE 30" is printed.
The following BBCBASIC(Z80) program is the program line editor (by Cambridge Computer Ltd) introduced in the "General Information" section.
It makes extensive use of CLI commands.
The listing below is interspersed with comments that do not form part of the program.
Example 3 6.5.1.3
The editor consists of 2 procedures.
The first creates a CLI command file that lists the line to a file and then calls the second procedure which cleans it up and uses it as redirected input before exiting.
The line to be edited is then left in the input buffer.
The Z88's line editor may then be used to edit the line as if it had just been typed in.
Make sure that the program does not end up here accidentally and then define the first procedure.
The procedure is called with the line number to edit.
Make sure this is not zero.
Build a CLI command file in: RAM.0 for later execution.
The file is called EE.CLI.
It will contain the following lines: Execute the CLI command file "EE.CLI" and then return.
The CLI command file is not actually executed by the CLI until control is passed to it.
As previously explained, this is when keyboard input is expected.
Consequently, the commands in the CLI command file will not be executed until BBCBASIC(Z80) returns to the immediate mode (after the ENDPROC).
Having built the CLI command file EE.CLI and queued it for action by the CLI, PROCE terminates and BBCBASIC(Z80) returns to the immediate mode.
When this happens, the CLI command file EE.CLI is executed an it sends: to the file E.CLI.
It then causes "PROCF" to be executed.
This is the procedure where the line to be edited is cleaned up and turned into an input file.
Force a keyboard input to signal to the CLI that the command file EE.CLI has terminated.
The line to be edited is the second line in the file E.CLI.
Open the file, throw away the first line (LIST "nnn" ), read the line to be edited and close the file.
We have the line that we want to edit in A$.
Now we use it to write a file (E.CLI again) that we can use as redirected input.
Change the CR at the end of the line to a "nul" .
We are going to use the file as input ad if we left the CR at the end, the line would be entered before we had a change to edit it.
Get rid of the "gash" file EE.CLI and move the cursor left ready for editing.
Redirect input to be taken from the file E.CLI and exit.
The line to be edited is now in the input buffer and may be edited as if it had just been typed in.
Printing
Introduction 7.1
There are several ways of sending output from BBCBASIC(Z80) to the printer, either by echoing input to the screen or by directing the output exclusively to the printer.
This section describes the various ways of sending output to the printer along with the advantages and drawbacks of each method.
It also describes the "Printer Filter" and the actions of the various control codes an "Escape" sequences.
Keyboard Control 7.2
You can echo characters which are sent to the screen to the printer.
Printer echo is controlled with the following key sequences.
This is not quite as straightforward as it at first appears.
In fact, starts a CLI command that sends a copy of characters sent to the screen to the printer as well.
The key sequence removes that CLI command.
Whilst the CLI command is active, the "CLI" indicator appears in the OZ window and page-waits do not occur during a program listing.
In addition to, you can cancel the CLi command in the normal way by pressing the <SHIFT >/; <ESCAPE> or <ESCAPE>.
Using printer echo is an easy way of listing a program on the printer.
In the following example, the "+" represents the "=/+" key; you don't have to use the <SHIFT> key.
From Within a Program 7.3
There are 2 ways of sending data to the printer from within a program.
The first involves the use of the Command Line Interpreter and the second used the BBCBASIC(Z80) command, PRINT#.
The former echoes characters sent to the screen to the printer.
It provides all the normal BBCBASIC(Z80) print control features, but it is more complicated to set up.
The latter sends characters to the printer only.
It is simple to set up, but it becomes more difficult to use as the complexity of the printed line increases.
The use of the Command Line Interpreter is explained at Appendix D to your Z88 manual and in the "Operating System Interface" section of this manual.
Using the CLI 7.3.1
Using CLI commands to send data to the printer has the advantage that the screen format is duplicated on the printer and all BBCBASIC(Z80)'s print format controls work.
You do not, however, have access to the special print controls provided by the Z88's Printer Filter and you are left with a suspended CLI command file (explained in the "Operating System Interface" section).
Consequently, this is the least favoured method unless you especially want to echo screen output to the printer.
It is possible to emulate pressing the key sequences and from within BBCBASIC(Z80) by sending these key sequences to the CLI.
At first glance, the following program line should work.
Remember that the "#" symbol is interpreted as by the CLI.
This does not achieve the desired effect within a program because the CLI command does not become active until the next attempt to read a character from the keyboard.
In order to activate the CLI command, the line needs to have an INKEY command at the end.
Since a star command must be the last (or only) command in a program line, you need to use the OSCLI command to pass the CLI command to the operating system.
Thus, the line becomes: Try this line out on the Z88.
You will see the CLI indicator in the status panel flash on and off again indicating that a CLI command sequence is momentarily active.
Unfortunately, the print echo is only active whilst the CLI indicator is present, so this not a lot of use to us!
In order to keep print echo active, we need to suspend the CLI command sequence after we have issued the print echo command.
Unfortunately, this needs 2 command lines and must be done using a CLI command file.
You will need to use PipeDream to create the following CLI command file.
Save it as plain text to a file named pon.cli.
Remember to save it as plain text -you will get all sorts of interesting error messages if you don't.
Once you have created this file, you can turn the printer on and off from within your program with the following program lines: All subsequent PRINT statements will print to the screen and the printer.
Printer On 7.3.1.1
The first line of the CLI file turns printer echo on by sending the command to the CLI.
In order to stop the printer echo being turned off at the end of the CLI command file, the CLI is suspended with the".
S"command on the next line.
Without the INKEY(O) command at the end of the program line, print echo would not be turned on until the program attempted to read from the keyboard or the program terminated and BBCBASIC(Z80) returned to the immediate mode.
Remember, you cannot cancel a suspended CLi command file from within a program.
The only way is to press the <SHIFT >/; <ESC> or <ESC> keys on the keyboard.
Consequently, you should avoid using this method of sending characters to the printer unless you really need to.
The use of CLI command files is explained more fully in the "Operating System Interface" section of the manual.
Subsequent PRINT statements will now only print to the screen.
Printer Off 7.3.1.2
This line sends to the CLI and turns printer echo off.
Unfortunately, this leaves the CLI suspended and there is no way to reactivate it from within your program.
You can, however, reactivate the CLI manually by pressing <SHIFT >/; <ESCAPE> when your program has terminated.
You may not initially notice the effect of having a suspended CLI command file.
However, when you list a program you will find that the listing no longer pauses automatically after every page.
You can also send output to the printer using the devices (hardware names): PRT.0 and: COM.0.
The: PRT.0 device filters output through a "filter" (device driver), the: COM.0 device sends output direct to the printer (serial port).
Using PRINT# 7.3.2
This method of printing does allow you to make use of the "Printer Filter" , but as the complexity of the line to be printed increases, this method becomes more difficult.
To send data to the printer in this way, you first open a file to the device and then use the PRINT# statement to send the characters to be printed to the printer.
Characters printed in this way do not appear on the screen.
When you send characters to the printer device: PRT.0 in this way, they are processed by the Printer Filter and all the codes described in the "Print Filter" sub-section are recognised and acted upon.
If you are using the: PRT.0 device, you must send the printer-on Escape sequence ENQ [(ASCII codes 5 & 91) to turn printing on before you send anything you want printed.
Remember to turn the printer off with the Escape sequence ENQ](ASCII codes 5 & 93) when you have finished.
The following example opens a file and prints to it via the Printer Filter.
It uses some printer Escape sequences which are discussed in the "Printer Escape Sequences" sub-section and it assumes that the Printer Editor has been used to set "Off at CR" to "No" for bold and underline.
PRINT# is intended for sending data to a file.
Consequently, it works in a different way to PRINT.
Items separated by commas or spaces are treated as different data fields and a carriage-return is sent between each field.
Consequently, you need to build and send a complete line at a time.
In addition, you must explicitly send the line-feed character at the end of the line.
If you are using the: COM.0 device, everything is sent to the printer and you don't need to turn it on and off.
However, you must send the printer specific control codes for underline, etc since the Printer Filter is not being used.
The Printer Filter 7.4
All output explicitly sent to the printer device: PRT.0 goes via the "Printer Filter" .
This filter examines every character to see if it has some special meaning or if it is to be translated into another character or sequence of characters.
The code translation and command codes may be edited using the"Printer Editor () as described in your Z88 Users' Guide.
Most printers have a set of control codes that switch the printer into similar modes.
However, whilst most printers provide a number of similar odes, the codes used are often different.
The "Printer Filter" provides a universal set of print format controls which may be used irrespective of the printer in use.
Provided you use the "Printer Editor" () to configure the Print Filter for your printer, your programs will work in exactly the same way irrespective of the printer in use.
The "Printer Filter On" and "Printer Filter Off" Escape sequences also turn the printing on and off.
So remember to use them at before and after printing.
The tables in the following sub-sections include program segments that will sent the appropriate codes to the printer file.
These assume that the printer file handle is in the variable "pf" and that ENQ$ is CHR$ (5).
The following codes toggle printer attributes such as bold print, underline, etc.
These toggles can be automatically reset at the next carriage-return by setting the "Off at CR" option in the Printer Editor to "Yes" .
By default, all the attribute toggles with the exception of "Alternate Font" ( "A" ) and "User Defined" ( "E" ) are automatically reset when a carriage-return is sent.
Printer Control Codes
Attributes 7.4.2
Unless you have used the Printer Editor to set "Off at CR" to "No" , you should use the "BPUT#" version of the commands.
If you use the "PRINT#" version of the commands, the terminating CR will undo its effect (excepting Printer On/Off and Alternate and User Defined fonts).
Unlike the screen control codes, the printer control codes cannot be strung together or explicitly set by preceding them with a "+" or "-" .
Neither is there a "reset all toggles" command.
The following control characters are not treated as commands by the Print Filter.
Like the normal printable characters (Space to Delete — & 20 to & 7f ) they may be translated, but they are otherwise sent directly to the printer.
Untrapped Characters 7.4.3
The "Operating System Interface" section of the manual describes how input and output may be redirected.
The diagram below may help you to visualise how and where redirection takes place.
It also illustrates how the Printer Editor and the PANEL affect the output.
Printer Redirection 7.4.4
Since you cannot issue CLI "dot" commands from the keyboard, you will need to write a CLI command file using PipeDream in order to redirect the printer input or output.
The CLI command file shown below would redirect printer output to a file called "pfile" .
If this file had been saved (in plain text format) as "predir" , you could initiate printer output redirection by issuing the command from the filter (), or in the immediate mode from within BBCBASIC(Z80).
If you wished to issue the command from within a BBCBASIC(Z80) program, you would need the following program line.
See the "Operating System Interface" section of the manual for an explanation of CLI command files.
The Serial Port 7.5
Hardware Connections 7.5.1
DTR is high when the Z88 is awake.
The Z88 is always awake when the screen is active.
Even if the Z88 is asleep, it will wake every minute or so to carry out various housekeeping tasks (checking the alarms, for example).
At these times, DTR will go high.
Pin 1 can be used to indicate that power is available to the Z88.
You can use the PANEL () to set up the parameters of the serial port (speed, parity, etc).
Output from and input to the serial port can be controlled either by software or hardware.
The hardware handshaking is always active, so if you only want to use software handshaking, you will need to wire a cable to set the handshaking lines high at all times.
You can do this by connecting pins 5, 8 and 9 together on the Z88 9-pin connector.
Flow Control 7.5.2
An external device (printer, modem, etc) can ask the Z88 to stop sending by either bringing the CTS line (pin 5) low or sending an XOFF (CHR$ (19)) character to the Z88.
Output 7.5.2.1
There is potentially a slight delay when using software handshaking.
Transmission will stop only after the XOFF character has been recognised and, since the Z88 has an input buffer, this can only happen after previously received characters have been processed.
With hardware flow control, transmission stops at the end of the next character.
Transmission is resumed when an XON (CHR$ (17)) character is received or the CTS line is brought high.
The output buffer is around 95 bytes long.
If software flow control is used, the Z88 will send XOFF to an external device once the receive buffer is more than half full.
Characters will continue to be received until there are only 15 spaces left in the buffer.
At this point, an XOFF character will be sent for every character subsequently sent by the external device.
If the receive buffer overflows, then the received data is lost.
The Z88 will send the XON character when the receive buffer has been cleared to less than half full.
Input 7.5.3
If hardware flow control is used, the Z88 will bring RTS low when the receive buffer becomes more than half full and bring RTS high when the receive buffer is less than a quarter full.
The input buffer is around 127 bytes long.
BBC BASIC(Z80) Files
Introduction 8.1
These notes start with some basic information o files, and then go on to discuss program file manipulation, simple serial files, random and, finally, indexed files.
The commands and functions used are explained, and followed by examples.
If you are new to BBCBASIC(Z80), or you are experiencing difficulty with (data) files you might find these notes useful.
Some of the concepts and procedures described are quite complicated and require an understanding of file structures.
If you have trouble understanding these parts, don't worry.
Try the examples and write some programs for yourself and then go back and read the notes again.
As you become more comfortable with the fundamentals, the complicated bits become easier.
The programs given in this manual are for demonstration and learning purposes; they are not intended to be taken and used as working programs without modification to suit your needs.
They are definitely NOT copyright and, if you want to, you are free to incorporate any of the code in the programs you write.
Use them, change then, or ignore them as you wish.
There is only one proviso; the programs have been tested and used a number of times, but we cannot say with certainty that they are bug free.
Remember, debugging is the art of taking bugs out -programming is the art of putting them in.
The Structure of Files 8.2
If you understand the way files work, skip the next 2 paragraphs.
If you understand random and indexed files, skip the following 2 paragraphs as well.
Many people are confused by the jargon that is often used to describe the process of storing and retrieving information.
This is unfortunate, because the individual elements are very simple and the most complicated procedures are only a collection of simple bits and pieces.
Basics 8.2.1
All computers are able to store and retrieve information from a non-volatile medium.
In other words, you don't lose the information when the power gets turned off.
Remember, pressing both <SHIFT> keys does not actually turn your Z88 off; removing the batteries would.
Audio cassettes may be used for small micro computers, diskettes for medium sized systems and magnetic tape and large disks for big machines.
Some computers, like the Z88, are designed so that the contents of RAM are not lost when the machine is "shut down" (pressing both <SHIFT> keys).
These computers can use RAM instead of tape or disk as a non-volatile storage medium.
RAM has several advantages of disks.
File access is very much quicker and there aren't any disks to lose, spill coffee over, etc.
In order to be able to find the information you want, the information has to be organised in some way.
All the information on one general subject is gathered together into a FILE.
Within the file, information on individual items is grouped together into RECORDS.
Look upon a cassette, a diskette or the Z88's RAM as a drawer in a filing cabinet.
The drawer is full of folders called FILES and each file holds a umber of enclosures called RECORDS.
Sometimes the files are in order in the drawer, sometimes not.
If you want a particular files, you start at the beginning of the drawer and search your way through until you find the file you want.
Then you search your way through the records in the file until you find the record you want.
Serial (Sequential) Files 8.2.2
This is very similar to the way a cassette is searched for a particular file.
You put the cassette in the recorder, type in the name of the file you want and push play.
You then go an make a cup of tea whilst the computer reads through all the files until it comes to the one you want.
Because the cassette is read serially from start to end, it's very difficult to do it any other way.
Life is easier with a computer that uses diskettes or RAM.
There is an index which tells the computer where to look for each of the files and a serial search for the file is not necessary.
However, once you have found the serial file you want, you still need to read through it to find the record you want.
There are a number of ways to overcome this problem.
We will consider the two simplest; random access (or relative) files and indexed files.
The easiest way to find the record you want is to identify each record with a number, like an account number.
You can then ask for, say, the 23rd record.
This is similar to turning to page 23 in the account book.
This works very well at first.
Every time you get a new customer you start a new page.
Most of the pages have a lot of empty space, but you must have the same amount of space available for each account, otherwise your numbering system won't work.
So, even at the start, there are a lot of gaps.
Random Access Files 8.2.3
What happens when you close an account?
You can't tear out the page because that would upset the numbering system.
All you can do is draw a line through it — in effect, turn it into a blank page.
Before long, quite a umber of pages will be "blank" and a growing proportion of your book is wasted.
With other forms of "numbering" , say by the letters of the alphabet, you could still not guarantee to fill all the pages.
You would have to provide room for the Zs, but you may never get one.
When you started entering data, most of the pages would be blank and the book would only gradually fill up.
The same happens with this sort of file stored in the Z88's RAM.
A random file which has a lot of empty space in it is described as sparse.
Most random files start this way and most never get more than about 3/4 full.
Count the number of empty "slot" in your address book and see what proportion this is of the total available.
If we wanted to hold our address book on the computer, we would need a number of records each holding the name, address, telephone number, etc of one person.
In our address book, we have one or two pages per letter of the alphabet an a number of"slots' on each page.
With this arrangement, the names are in alphabetical order of their first letter.
This is very similar to the way the accounts book was organised except that we don't know the page number for each name.
Indexed Files 8.2.4
If we had an index at the front of the book we could scan the index for the name and then turn to the appropriate page.
We would still be wasting a lot of space because some names, addresses etc are longer than others and our "slots" must be large enough to hold the longest.
Suppose we numbered all the character positions in the book and we could easily move to any character position.
We could write all the names, addresses, etc, one after the other and our index would tell us the character position for the start of each name and address.
There would be no wasted space and we would still be able to turn directly to the required name.
What would happen when we wanted to cancel an entry?
We would just delete the name from the index.
The entry would stay in its original place in the book, but we would never refer to it.
Similarly, if someone changed their address, we would just write the name and the new address immediately after the last entry in the book and change the start position in the index.
Every couple of years we would rewrite the address book, leaving out those items not referenced in the index and up-date the index (or write another one).
This is not a practical way to run a paper and pencil address book because it's not possible to turn directly to the 3423rd character in a book, and the saving in space would not be worth the tedium involved.
However, with BBC BASIC you can turn to a particular character in a file an the tedium only takes a couple of seconds, so it's well worth doing.
Files in BBCBASIC(Z80) 8.3
Introduction 8.3.1
Conventional serial file procedures are little different from file procedures for cassette based computers.
With serial files the records need only be as large as the data to be stored and there are no empty records.
(The data item FRED only occupies 4 bytes whereas ERMINTRUDE occupies 10 bytes.)
Consequently serial files are the most space efficient way to hold data in any storage medium.
Serial files cannot be used to access particular records from within the file quickly and easily.
In order to do this with the minimum access time, random access files are necessary.
However, a random file generally occupies more space than a serial file holding the same amount of data because the records must be a fixed length and some of the records will be empty.
Most versions of BASIC only offer serial and random files, but because of the way that files re handled by BBC BASIC (both on the BBC Computer and the Z88 using BBCBASIC(Z80)), it is possible to construct indexed, and even linked, files as well.
Indexed files take a little longer to access than random files and it is necessary to have a separate index file, but they are generally the best space/speed compromise for files holding a large amount of data.
As far as the programmer is concerned, data can be written to and read from a file a data item or a character (byte) at a time.
In fact, there is a buffer between the program and the operating system, but this need only concern you when you are organising your program for maximum file access efficiency.
How Data is Read/Written 8.3.2
Because of the character by character action of the write/read process, it is possible (in fact, necessary) to keep track of your position within the file.
BBC BASIC does this for you automatically and provides a pointer PTR# (a pseudo-variable) which holds the position of the NEXT character (byte) to be written/read.
Every time a character is written/read PTR# is incremented by 1, but it is possible to set PTR# to any number you like.
This ability to "jump around" the file enables you to construct both random (relative) and indexed files.
BBC BASIC provides the facility for completely free-format binary data files.
Any file which can be read by the computer, from any source and in any data format, can be processed using the BGET#, BPUT# and PTR# functions.
Data files written by the PRINT# statement and read by the INPUT# statement have a different format to files produced by similar statements on the BBC Micro.
This only becomes significant when calculating record sizes for random access files.
Record sizing is discussed at the "Random (Relative) Files" sub-section.
How Data is Stored 8.3.3
Stored data is not "typed" , so a "Type mismatch" error is never produced when reading files.
In order to make the most efficient use of space and to preserve accuracy, numerics are stored in a data file in binary format, not as strings of characters.
To prevent confusion when numerics are being read from a file, both integers and reals occupy 5 bytes (40 bits).
If they were stored as character strings they could occupy up to 10 bytes.
For compatibility with other BASICs, you can store numerics as strings by using the STR$ () function.
Numeric Data 8.3.3.1
Strings are stored in a data file as the ASCII bytes of the string followed by a carriage-return.
A string, therefore, occupies one more byte than the length of the string.
If no carriage-return is found within 256 characters when reading a string value, a null string is returned.
How Strings are Stored 8.3.3.2
If you need a line feed as well, it's no problem to add it using the Byte-Put function BPUT#.
Similarly, extraneous characters included in files produced by other programs can be read and, if necessary, discarded using BGET#.
We refer to a file (or device) by its name.
Unfortunately, this is too complicated for the Z88's operating system.
Consequently, the only time the operating system refers to a file by its name is when it opens the file.
From then on, it refers to the file by the number it allocated to it when it was opened.
This number is called the "file handle" .
How Files are Referred To 8.3.4
The Z88 has a uniform device independent I/0 system.
Although procedures do exist that will explicitly send data directly to, for example, the serial port, it is more logical to think of these devices as "files" and use the standard file I/0 interface.
The Z88 Filing System 8.3.5
For example, to send data to the communications port (serial port without the printer filter), you can open a file to: COM.0 and PRINT to it just as if you were PRINTing to a file.
Remember, you need to explicitly send the line-feed.
See the "Operating System Interface" and "Printing" sections for more details.
Logically, you can only write to and read from the I/0 devices in a sequential manner.
It makes no sense, for example, to try to set the file pointer with PTR#.
File Access Commands 8.4
Introduction 8.4.1
The commands and statements used in file manipulation are described below.
They are not in alphabetical order, but in the order you are likely to want to use them.
Whilst these notes repeat much of the material covered in the "Statements and Functions" section, additional information has been added and they are presented in a more readable order.
Please refer to your "Z88 Users' Guide" for a full explanation of device, directory and file names.
The explanation below is only intended as a brief reference guide.
Filenames 8.4.2
The Z88's operating system allows a composite file name in the following format: The devicename is the name of a memory bank or a physical device.
This can be: The final .0 of a device name may be omitted if the device is unique.
For example,: COM.0 may be abbreviated to: COM.
There is a bug in versions of the filer up to and including version 3 that will cause the Z88 to crash if you use the device: RAM- and then perform a soft reset whilst any files are still present in the device.
You can avoid this problem by deleting any files in: RAM- as soon as you have finished with them.
The pathname is the name of the directory or the path to the directory in which the file will be found or created.
The file name can be up to 12 characters long, and the extension up to 3 characters.
Simple examples are given throughout this section with the explanation of the various commands.
The following sections contain examples of complete programs for serial files and random files.
Finally, more complex random and indexed files are discussed.
If you have problems understanding the action of any of the commands you may find the examples helpful.
The best way to learn is to do — so have a go.
Organisation of Examples 8.4.3
Save the current program to a file, in internal (tokenised) format.
The filename can be a variable or a string.
Program File Manipulation 8.4.4
SAVE 8.4.4.1
The first example will save the program to a file named FRED.
The second will save COMPOUND.
You can specify a devicename and a path as well as the file name.
The following example will save the current program to a file called TEST in a directory called PROGS which is in a directory called BBCBASIC on device: RAM.0.
(The full device/path/file is: RAM.0/BBCBASIC/PROGS/TEST)
Load the program "filename" into the program area.
The old program is deleted (as if a NEW command had been given prior to the LOAD) and all the dynamic variables are cleared.
The program must be in tokenised format.
File names must conform to the standard Z88 format.
LOAD 8.4.4.2
As with SAVE, you can specify a device name and path.
The example below loads the program saved previously as an example of the SAVE command.
LOAD and RUN the program "filename" .
All the dynamic variables are cleared.
The program must be in tokenised format.
CHAIN 8.4.4.3
As with SAVE and LOAD, you can specify a device name and/or a path.
Delete the file "filename" .
Since variables are not allowed as arguments to * commands, the filename must be a constant.
*DELETE 8.4.4.4
*ERASE is synonymous with *DELETE.
To delete a file whose name is known only at run-time, use the OSCLI command.
It's a bit clumsy, but a lot better than the original specification for BBC BASIC allowed.
This time all of the command, including the DELETE must be supplied as the argument for the OSCLI command.
You can use OSCLI for deleting a file whose name is a constant, but you must include all of the command line — in quotes this time.
You can include a drive name and/or a path in both the *DELETE an *OSCLI command formats.
Rename "file1" to be called "file2" .
Once again, if you want to rename files whose names are only known at run-time, you must use the OSCLI command.
*RENAME 8.4.4.5
If you attempt to rename an open file, an "In use" error will be reported.
Files and Devices 8.4.5 Introduction 8.4.5.1 The statements and functions used for data files and devices are: As explained under the individual keywords, EXT#-1, PRT#-1 and EOF#-1 return system information.
You cannot use a file until you have told the system it exists.
In order to do this you must OPEN the file for use.
Other versions of BASIC allow you to choose the file number.
In order to improve efficiency, BBCBASIC(Z80) chooses the number for you.
Opening Files 8.4.5.2
When you open the file, a file handle (an integer number) is returned by the interpreter and you will need to store it for future use.
The open commands are, in fact, functions which open the appropriate file and return its file handle.
You use the file handle for all subsequent access to the file.
(With the exception of the STAR commands outlined previously.)
If the system has been unable to open the file, the handle returned will be 0.
This will occur if you try to open a non-existent file in the input mode (OPENIN or OPENUP).
The Z88's operating system imposes a limit on the number of files you can have open at any one time.
The limit is 10 for BBCBASIC(Z80) and 90 for the whole filing system.
If you attempt to have more files open at one time than allowed for BBCBASIC(Z80), the file will not be created and you will get a "Too many files open" error.
If you try to exceed the limit for the filing system, you will get a "No room" error.
The 3 functions which open files are OPENIN, OPENUP and OPENOUT.
OPENOUT should be used to create new files, or overwrite old ones.
OPENIN should be used for input only and OPENUP should be used for input/output.
File Opening Functions 8.4.5.3
Open the file "filename" for output and return the file handle allocated.
The use of OPENOUT destroys the contents of the file if it previously existed.
(The directory is updated with the length of the new file you have just written when you close the file.)
OPENOUT 8.4.5.4
You always need to store the file handle because it must be used for all the other file commands and functions.
If you choose a variable with the same name as the file, you will make programs which use a number of files easier to understand.
Open the file "filename" for input only.
OPENIN 8.4.5.5
You will be unable to open for input (file handle returned = 0) if the files not already exist.
If you try to write to a file opened for input you will get a "Write protected" error (error number 252).
Open the file "filename" for update (input or output) without destroying the contents of the file.
The file may be read from or written to.
When the file is closed, the directory is updated to show the maximum used length of the file.
None of the previously written data is lost unless it has bee overwritten.
Consequently, you would use OPENUP for reading serial and random files, adding to the end of serial files or writing to random files.
OPENUP 8.4.5.6
You will be unable to open for update (file handle returned = 0) if the file does not already exist.
Close the file opened as "fnum" .
CLOSE#0, END or "dropping off the end of a program" will close all files.
CLOSE# 8.4.5.7
Read from the file opened as "fnum" into the variable "var" .
Several variables can be read using the same INPUT# statement.
INPUT# 8.4.5.8
If you attempt to read beyond the current end of the file, you will get an "End of file" error.
READ# can be used as an alternative to INPUT# Write the variable "var" to the file opened as "fnum" .
Several variables can be written using the same PRINT# statement.
PRINT# 8.4.5.9
String variables are written as the character bytes in the string plus a carriage-return.
Numeric variables are written as 5 bytes of binary data.
Return the total length of the file opened as "fnum" .
EXIT# 8.4.5.10
In the case of a sparse random-access file the value returned is the length of the file to the last byte actually written to the file.
Although much of the file may well be unused, writing this "last byte" reserved physical space in RAM for a file of this length.
Thus it is possible to write a single byte to a file and get a "No room" error.
EXT#-1 returns an estimate of the amount of free memory in bytes.
See the Annex entitled "Format of Program and Variables in Memory" for more details.
A pseudo-variable which points to the position within the file from where the next byte to be read will be taken or where the next byte to be written will be put.
PTR# 8.4.5.11
When the file is OPENED, PTR# is set to zero.
However, you can set PTR# to any value you like.
(Even beyond the end of the file — so take care).
Reading or writing, using INPUT# and PRINT#,(and BGET# and BPUT# — explained later), takes place at the current position of the pointer.
The pointer is automatically updated following a read or write operation.
A file opened with OPENUP may be extended by setting PTR# to its end (PTR# = EXT#), and then writing the new data to it.
You must remember to CLOSE such a file in order to update its directory entry with its new length.
A couple of examples of this are included in the sections on serial and indexed files.
PTR#-1 returns the number of file handles available for use and the ROM release number.
If you are going to display this information, you will need to do so in hexadecimal because the one (4 byte) number contains 2 items of information For example, The last 4 digits (least significant 2 bytes) are the ROM release number.
the first 2 digits (most significant 2 bytes) are the number of files handles still available for use by the filing system (& 5a =90).
A function which will return -1 (TRUE) if the data file whose file handle is the argument is at (or beyond) its end.
In other words, when PTR# points beyond the current end of the file.
EOF# 8.4.5.12
Attempting to read beyond the current end of file will give rise to an "End of file" error.
EOF# is only really of use when dealing with serial (sequential) files.
It indicates that PTR# is greater than the recorded length of the file (found by using EXT#).
When reading a serial file, EOF# would go true when the last byte of the file had been read.
EOF# is only true if PTR# is set beyond the last byte written to in the file.
It will NOT be true if an attempt has been made to read from an empty area of a sparse random access file.
Reading from an empty area of a sparse file will return garbage.
Because of this, it is difficult to tell which records of an uninitialised random access file have had data written to them and which are empty.
These files need to be initialised and the unused records marked as empty.
Writing to a byte beyond the current end of file updates the file length immediately, whether the record is physically written to the file at that time or not.
EOF#-1 returns TRUE for an expanded machine( >=; 128Kbytes of RAM in SLOT 1) and FALSE for an unexpanded machine.
A function which reads a byte of data from the file opened as "fnum" , from the position pointed to by PTR#fnum.
PTR#num is incremented by 1 following the read.
A positive integer between 0 and 255 is returned (as you might expect).
This can be converted into a string variable using the CHR$ function.
BGET# 8.4.5.13
Write the least significant byte of the variable "var" to the file opened as "fnum" , at the position pointed to by PTR#fnum.
PTR#fnum is incremented by 1 following the write.
BPUT# 8.4.5.14
Serial Files 8.6
Introduction 8.6.1
The section on serial files is split into 3 parts.
The first deals with character data files.
These are the simplest type of files to use and the examples are correspondingly short.
The second part looks at mixed numeric/character data files.
The final part describes conversion between BBCBASIC(Z80) format files and the file formats required/produced by other systems.
In a number of instances, the program lines are too long for the printed page.
When this occurs, they are "folded round" without adding a line number.
This won't, of course, work in the actual program.
The first 3 examples are programs to write data in character format to a serial file and to read the data back.
All the data is in character format and, since the files will not be read by other versions of BASIC, no extra control characters have been added.
Character Data Files 8.6.2
You may notice that we have cheated a little in that a procedure is called to close the files and end the program without returning.
This saves using a GOTO, but leaves the return address on the stack.
However, ending a program clears the stack and no harm is done.
You should not use this sort of trick anywhere else in a program.
If you do you will quickly use up memory.
The next example extends the write program from Example 1.
This new program opens the file, sets PTR# to the end (line 380) and then adds data to it.
A procedure is used to open the file.
This has the advantage of making the program more understandable by putting the details "open at end" coding out of the main flow of the program.
Ex 1 — Writing Serial Character Data 8.6.2.1
Ex 3 — "AT END" of Character Files 8.6.2.3
The second 3 examples are also programs which write data to a file and read it back, but this time the data is mixed.
They are simply extensions of the previous examples which illustrate the handling of mixed data.
Mixed Numeric/Character Data Files 8.6.3
Ex 4 — Writing a Mixed Data File 8.6.3.1